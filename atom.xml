<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张小轩的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.zhangyongxuan.com/"/>
  <updated>2022-03-16T10:40:17.087Z</updated>
  <id>https://www.zhangyongxuan.com/</id>
  
  <author>
    <name>张小轩</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React实现简单的分页器组件</title>
    <link href="https://www.zhangyongxuan.com/2021/11/10/reactPagination/"/>
    <id>https://www.zhangyongxuan.com/2021/11/10/reactPagination/</id>
    <published>2021-11-10T06:41:08.000Z</published>
    <updated>2022-03-16T10:40:17.087Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><em>在日常的开发中，一般用到分页器的时候都是使用一些UI组件库里封装好的组件，假如离开了这些组件库该怎么办？这时候只能自己封装一个简单地分页器了</em></strong></p><a id="more"></a><h1 id="一、分页器需要的参数"><a href="#一、分页器需要的参数" class="headerlink" title="一、分页器需要的参数"></a>一、分页器需要的参数</h1><h2 id="一个简单分页器所需要的主要参数有四个，分别是："><a href="#一个简单分页器所需要的主要参数有四个，分别是：" class="headerlink" title="一个简单分页器所需要的主要参数有四个，分别是："></a>一个简单分页器所需要的主要参数有四个，分别是：</h2><pre><code>onChange  // 页码变化时的回调函数 functiontotal   // 数据总数 numberpageSize // 每页数据数 numbercurrentPage // 当前页页码 number</code></pre><p>根据total和pageSize可以算出总页数 totalPage = total/size<br>当total和size中任何一个发生变化时都需要重新计算totalPage   </p><h2 id="还有一个比较特殊的内部参数：步长-step"><a href="#还有一个比较特殊的内部参数：步长-step" class="headerlink" title="还有一个比较特殊的内部参数：步长 step"></a>还有一个比较特殊的内部参数：步长 step</h2><p>这个参数非常重要，表示向前step页，向后step页。而在分页器的展示形态里也起着至关重要的作用，step一般来说是奇数，在这里我管Math.ceil(step/2)叫半步长</p><h1 id="二、-分页器的展示形态"><a href="#二、-分页器的展示形态" class="headerlink" title="二、 分页器的展示形态"></a>二、 分页器的展示形态</h1><p>分页器的展示形态是取决于当前页、总页数和步长<br>如果总页数少，那么就会显示所有页，如果总页数多那么就会出现左右省略号<br>左省略号点击之后是向前step页，右省略号点击之后是向后step页 </p><p>首先，分页器的展示形态分为有省略号和无省略号两种，而不管有没有省略号，第一页和最后一页以及向前（后）1页都是显示的</p><h2 id="1、无省略号的情况分为2种"><a href="#1、无省略号的情况分为2种" class="headerlink" title="1、无省略号的情况分为2种"></a>1、无省略号的情况分为2种</h2><p>第一种：第一页就是最后一页，此时的分页器形态为：</p><pre><code>&lt; 1 &gt;</code></pre><p>第二种：总页数大于1且小于等于步长+1，这时候分页器的形态为：</p><pre><code>&lt;  1  2  3  4  5  &gt;</code></pre><h2 id="2、有省略号的情况分为三种情况，此时总页数必然是大于步长-1的"><a href="#2、有省略号的情况分为三种情况，此时总页数必然是大于步长-1的" class="headerlink" title="2、有省略号的情况分为三种情况，此时总页数必然是大于步长+1的"></a>2、有省略号的情况分为三种情况，此时总页数必然是大于步长+1的</h2><p>第一种情况： 无左省略号，有右省略号 ， 分页器形态为：</p><pre><code>&lt;  1  2  3  4  5  &gt;&gt;  10  &gt;</code></pre><p>第二种情况： 有左省略号，无右省略号 ， 分页器形态为：</p><pre><code>&lt;  1  &lt;&lt;  6  7  8  9  10  &gt;</code></pre><p>第二种情况： 有左省略号，无右省略号 ， 分页器形态为：</p><pre><code>&lt;  1  &lt;&lt;  6  7  8  9  10  &gt;</code></pre><p>第三种情况： 有左省略号，无右省略号 ， 分页器形态为：</p><pre><code>&lt;  1  &lt;&lt;  6  7  8  9  10  &gt;&gt;  50  &gt;</code></pre><h1 id="三、-源码"><a href="#三、-源码" class="headerlink" title="三、 源码"></a>三、 源码</h1><p>index.js : </p><pre><code>/* eslint-disable react-hooks/exhaustive-deps */import React, { useEffect, useState } from &quot;react&quot;;import &quot;./style.scss&quot;;const step = 5; // 步长const halfStep = Math.ceil(step / 2); // 当前页前后页数const Pagination = ({  onChange = (e) =&gt; e,  total = 500,  pageSize = 10,  currentPage = 1,  sizeOptions = [10, 20, 30, 40, 50]}) =&gt; {  const [current, setCurrent] = useState(currentPage);  const [size, setSize] = useState(pageSize);  const [pageItemList, setPageItemList] = useState([]);  const [totalPage, setTotalPage] = useState(0);  const [showSizeList, setShowSizeList] = useState(false);  /**   * 向前/后 步长页   * @param {*} type   * @returns   */  const getJumpItem = ({ type }) =&gt; {    return {      type,      text: type &gt; 0 ? &quot;&gt;&gt;&quot; : &quot;&lt;&lt;&quot;,      num: Math.random(),      title: `向${type &gt; 0 ? &quot;后&quot; : &quot;前&quot;}${step}页`    };  };  useEffect(() =&gt; {    setTotalPage(Math.ceil(total / size));  }, [total, size]);  useEffect(() =&gt; {    onChange({ total: totalPage, currentPage: current });  }, [current, size]);  // 核心逻辑  useEffect(() =&gt; {    const subList = []; // 除了第一页和最后一页中间的部分    if (totalPage &gt; step + 1) {      // 总页数大于步长+1说明有省略      if (current - halfStep &lt; 1) {        // 当前页-半步长小于1不显示向前步长数        for (let i = 1; i &lt;= step; i++) {          if (i &lt; step) {            subList.push({              type: 0,              text: i + 1,              num: i + 1,              title: i + 1            });          } else {            // 最后一页push向后步长页            subList.push(getJumpItem({ type: 1 }));          }        }      } else if (current + halfStep &gt; totalPage) {        //  当前页+半步长大于总页数不显示向后步长页        for (let i = totalPage - step; i &lt; totalPage; i++) {          if (i === totalPage - step) {            // 第一个push向前步长页            subList.push(getJumpItem({ type: -1 }));          } else {            subList.push({              type: 0,              text: i,              num: i,              title: i            });          }        }      } else {        // 同时显示向前和向后步长页        for (let i = 1; i &lt;= step + 2; i++) {          const opr = i - halfStep - 1;          if (i === 1 &amp;&amp; current - halfStep !== 1) {            subList.push(getJumpItem({ type: -1 }));            console.log(-1);          } else if (i === step + 2 &amp;&amp; current + halfStep !== totalPage) {            console.log(1);            subList.push(getJumpItem({ type: 1 }));          } else if (i &gt; 1 &amp;&amp; i &lt; step + 2) {            console.log(current + 1);            subList.push({              type: 0,              text: current + opr,              num: current + opr,              title: current + opr            });          }        }      }    } else if ((totalPage &gt; 2 &amp;&amp; totalPage &lt;= step) || totalPage === step + 1) {      /***       * 总页数大于2且小于等于步长时除了第一页和最后一页中间还有总页数-2 从第二页开始       * 总页数刚好等于步长时也是一样的逻辑       */      for (let i = 2; i &lt; totalPage; i++) {        subList.push({          type: 0,          text: i,          num: i,          title: i        });      }    }    if (totalPage &gt; 1) {      setPageItemList([        {          type: 0,          text: 1,          num: 1,          title: 1        },        ...subList,        {          type: 0,          text: totalPage,          num: totalPage,          title: totalPage        }      ]);    } else if (totalPage !== 0) {      setPageItemList([        {          type: 0,          text: 1,          num: 1,          title: 1        }      ]);    }  }, [totalPage, current]);  const leftTxt = &quot;&lt;&quot;,    rightTxt = &quot;&gt;&quot;;  return (    &lt;div className=&quot;pagination-container&quot;&gt;      &lt;ul className=&quot;pagination-sub-container&quot;&gt;        {current !== 1 &amp;&amp; (          &lt;li onClick={() =&gt; setCurrent(current - 1)}&gt;{leftTxt}&lt;/li&gt;        )}        {pageItemList.map(({ type, num, text, title }) =&gt; {          const eleProps = {            title,            key: num          };          if (type === 0) {            eleProps.style = {              border: num !== current ? &quot;1px solid gainsboro&quot; : &quot;1px solid gray&quot;            };            eleProps.onClick = () =&gt; {              if (num !== current) {                setCurrent(num);              }            };          } else {            eleProps.onClick = () =&gt; {              let curP = current + step * type;              if (curP &gt; totalPage) {                curP = totalPage;              }              if (curP &lt; 1) {                curP = 1;              }              setCurrent(curP);            };          }          return &lt;li {...eleProps}&gt;{text}&lt;/li&gt;;        })}        {current !== totalPage &amp;&amp; (          &lt;li onClick={() =&gt; setCurrent(current + 1)}&gt;{rightTxt}&lt;/li&gt;        )}        &lt;li          className=&quot;size&quot;          onClick={() =&gt; {            setShowSizeList(!showSizeList);          }}        &gt;          {size}条/页 ↓          {showSizeList &amp;&amp; (            &lt;ul className=&quot;set-size-box&quot;&gt;              {sizeOptions.map((item) =&gt; (                &lt;li                  onClick={() =&gt; {                    setCurrent(1);                    setSize(item);                    setShowSizeList(false);                  }}                &gt;                  {item}                &lt;/li&gt;              ))}            &lt;/ul&gt;          )}        &lt;/li&gt;      &lt;/ul&gt;      &lt;div style={{ clear: "both" }} /&gt;    &lt;/div&gt;  );};export default Pagination;</code></pre><p>style.scss:</p><pre><code>.pagination-container {  float: left;  .pagination-sub-container {    position: relative;    float: left;    li {      list-style-type: none;      display: inline-block;      width: 40px;      height: 40px;      line-height: 40px;      text-align: center;      margin: 5px;      border-radius: 8px;      font-size: 14px;      box-sizing: border-box;      cursor: pointer;      -moz-user-select: none;      -webkit-user-select: none;      -ms-user-select: none;      user-select: none;      border: 1px solid gainsboro;    }    li:hover {      border: 1px solid gray;    }    .size {      min-width: 80px;      border: 1px solid gray;      position: relative;      .set-size-box {        float: left;        // height: 40px;        // line-height: 40px;        // border-radius: 8px;        // vertical-align: middle;        padding: 0;        margin: 0;        li {          min-width: 100%;          margin: 0;        }      }    }  }}</code></pre><p> <a href="https://codesandbox.io/s/components-test-phrpl?file=/src/Pagination/index.js" target="_blank" rel="noopener">自己试试</a></p><script type="text/javascript" src="/js/src/bai.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;在日常的开发中，一般用到分页器的时候都是使用一些UI组件库里封装好的组件，假如离开了这些组件库该怎么办？这时候只能自己封装一个简单地分页器了&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://www.zhangyongxuan.com/categories/React/"/>
    
    
      <category term="react" scheme="https://www.zhangyongxuan.com/tags/react/"/>
    
      <category term="es6" scheme="https://www.zhangyongxuan.com/tags/es6/"/>
    
      <category term="UI组件" scheme="https://www.zhangyongxuan.com/tags/UI%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>爬虫利器Puppeteer</title>
    <link href="https://www.zhangyongxuan.com/2021/10/31/Puppeteer/"/>
    <id>https://www.zhangyongxuan.com/2021/10/31/Puppeteer/</id>
    <published>2021-10-31T08:51:52.000Z</published>
    <updated>2021-11-10T06:34:24.306Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><em>Puppeteer 翻译是操纵木偶的人，利用这个工具，我们能做一个操纵页面的人。Puppeteer是一个Nodejs的库，支持调用Chrome的API来操纵Web，相比较Selenium或是PhantomJs,它最大的特点就是它的操作Dom可以完全在内存中进行模拟既在V8引擎中处理而不打开浏览器，而且关键是这个是Chrome团队在维护，会拥有更好的兼容性和前景。</em></strong><br><a id="more"></a></p><h1 id="Puppeteer可以做什么"><a href="#Puppeteer可以做什么" class="headerlink" title="Puppeteer可以做什么"></a>Puppeteer可以做什么</h1><ul><li>利用网页生成PDF、图片</li><li>爬取SPA应用，生成预渲染内容</li><li>可以从网站抓取内容</li><li>自动化表单提交、UI测试、键盘输入等</li><li>自动化测试</li><li>捕获站点的时间线，帮助站长分析网站性能问题</li></ul><h1 id="Puppeteer使用"><a href="#Puppeteer使用" class="headerlink" title="Puppeteer使用"></a>Puppeteer使用</h1><h2 id="安装Puppeteer"><a href="#安装Puppeteer" class="headerlink" title="安装Puppeteer"></a>安装Puppeteer</h2><p> 可以直接使用npm去安装puppeteer</p><pre><code> npm i puppeteer</code></pre><p> <a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageclickselector-options" target="_blank" rel="noopener">puppeteer API</a></p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li>const browser = await puppeteer.launch() 启动浏览器实例,得到一个浏览器实例</li><li>const page = await browser.newPage() 得到一个新的页面</li><li><p>await page.goto([URL]) 跳转到某一页</p><h1 id="小DEMO"><a href="#小DEMO" class="headerlink" title="小DEMO"></a>小DEMO</h1><pre><code>const puppeteer = require(&#39;puppeteer&#39;);(async ()=&gt;{const browser = await puppeteer.launch({headless: false}); //获得一个浏览器实例const page = await browser.newPage(); //得到一个浏览器页面实例await page.goto(&#39;http://localhost:8000&#39;); // 跳转到指定URLawait page.waitFor(5000); //等待5sawait page.focus(&#39;#username&#39;); // 使id为username的元素获得焦点await page.type(&#39;#username&#39;, &#39;13131313132&#39;, {delay: 100}); // 在id为username的输入框输入指定字符串，每字符间延时100msawait page.focus(&#39;#password&#39;);await page.type(&#39;#password&#39;, &#39;hand1234&#39;, {delay: 100});await page.click(&#39;#submitLogin&#39;); //点击id为submitLogin的按钮await page.waitFor(5000);const result = await page.evaluate(()=&gt;{ //在这个函数中可以向页面嵌入脚本，使用js为所欲为了 alert(111); return {}})})()</code></pre></li></ul><script type="text/javascript" src="/js/src/bai.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;Puppeteer 翻译是操纵木偶的人，利用这个工具，我们能做一个操纵页面的人。Puppeteer是一个Nodejs的库，支持调用Chrome的API来操纵Web，相比较Selenium或是PhantomJs,它最大的特点就是它的操作Dom可以完全在内存中进行模拟既在V8引擎中处理而不打开浏览器，而且关键是这个是Chrome团队在维护，会拥有更好的兼容性和前景。&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Nodejs" scheme="https://www.zhangyongxuan.com/categories/Nodejs/"/>
    
    
      <category term="node" scheme="https://www.zhangyongxuan.com/tags/node/"/>
    
      <category term="爬虫" scheme="https://www.zhangyongxuan.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>jq实现分页</title>
    <link href="https://www.zhangyongxuan.com/2021/09/18/jqpagination/"/>
    <id>https://www.zhangyongxuan.com/2021/09/18/jqpagination/</id>
    <published>2021-09-18T08:09:19.000Z</published>
    <updated>2021-11-10T06:34:24.306Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><em>一直在写vue和react的项目，习惯了有组件的快乐生活，近期突然项目上让去写一个jQuery模块，一脸懵逼，jQuery是啥？分页？果然生于忧患，死于安乐呀，赶紧写个分页小demo压压惊</em></strong><br><a id="more"></a></p><hr><p>首先介绍一下我们前端大家庭的元老级成员–jQuery<br> 英文名：jQuery<br> 中文名： 极快瑞<br> 出生日期：2006年1月<br> 老爸： John Resig（歪果仁）<br> 码生理想： 立志成为一个为互联网扫清兼容性问题的代码库<br> 简介：jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。</p><hr><p>言归正传，在我们前端的世界里，jq是每个前端程序猿的必经之路，有道是jq不通，何以通前端？虽然jq在今天的项目中逐渐的被react、vue等新型的MVVM框架替代，但是由于它上手快，接近原生，门槛低等特点，还是作为一个前端入门级框架被大家所学习，在这里记录一个jq实现分页的小demo，以便以后查阅。</p><p>首先需要写dom，分页组件的dom结构如下（css样式因需求而异）：</p><pre><code>&lt;!--page-box这个div就是整个分页的容器--&gt;&lt;div class=&quot;page-box&quot;&gt; &lt;!--page-total这个span是显示当前数据是从第几条到第几条--&gt;    &lt;span id=&quot;page-total&quot;&gt;&lt;/span&gt;&lt;!--这个div是上一页按钮--&gt;    &lt;div id=&quot;prev&quot;&gt;&lt;a&gt;&lt;&lt;/a&gt;&lt;/div&gt;&lt;!--这个ul是页码的容器--&gt;        &lt;ul id=&quot;page&quot;&gt;&lt;/ul&gt;&lt;!--这个div是下一页按钮--&gt;    &lt;div id=&quot;next&quot;&gt;&lt;a&gt;&gt;&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>下面实现分页小demo顺便复习复习jq的ajax（经典）<br>js部分：</p><pre><code>// 首先需要封装一个使用ajax请求接口的函数function fetchList(page){    $.ajax({        url: &#39;******&#39;, // 请求接口地址        async: true, // 请求类型 true/异步 false/同步        dataType: &#39;json&#39;, // 预期的服务器响应的数据类型        type: &#39;get&#39;, // 请求类型 可选值有 get/post/update/delete        data:page,//请求参数        beforeSend:function(xhr){}, // 请求发送之前的回调函数，回传的参数为xhr对象        complete:function(xhr,status){}, // 请求完成时的回调（无论请求成功与否），回传的参数为xhr对象和请求结果状态        success:function(res,status,xhr){            if(res&amp;&amp;res.content.length&gt;0){                page(res);            }        },//请求成功时的回调，回传的参数为响应体，状态和xhr对象        error: function(xhr,status,error){},//请求失败时的回调，回传的参数为xhr对象，状态和错误信息    })}// 封装一个方法来渲染分页部分的dom 这函数接受一个参数，为ajax请求成功后返回的带分页信息的响应体，在ajax请求成功并得到数据的时候调用该函数function page(res){    // 每次调用改方法时页码容器和显示数据条数的容器都要清空    $(&#39;#page-total&#39;).empty();    $(&#39;#page&#39;).empty();    // 从相应体中获取分页需要的一些参数    var total = res.totalElements; // 数据总数    var currentPage = res.currentPage;    // 当前页    var size = res.size; // 每页数据条数    var totalPages = res.totalPages; // 总页数    var start = currentPage == 0 ? 1 : currentPage*size + 1; // 当前页第一条数据在总数据中的位置，如果是第一页则是第一条，若不是则是第(当前页码*每页数据条数+1)条    var end = currentPage == totalPages-1 ? total : currentPage*size + size;// 当前页最后一条数据在总数据中的位置，如果是最后一页则是第（数据总数）条，若不是则是（当前页码*每页数据条数+每页数据条数）    $(&quot;#page-total&quot;).append(&quot;显示&quot;+start+&quot;-&quot;+end+&quot; 共 &quot;+total+&quot;条&quot;);     // 渲染页码    $(&#39;#next&#39;).attr(&#39;total-pages&#39;,totalPages);  // 在这里为下一页按钮的div添加一个自定义属性total-pages，记录总页数，用来判断书否进行下一页操作    // 接下来就是渲染页码    for (var i = 0;i&lt;totalPages;i++){        if(i==page) //判断当前页是不是该按钮控制的那一页，如果是就添加一个active类名            $(&#39;#page&#39;).append(&quot;&lt;li class=&#39;active&#39; current-page=&quot;+page+&quot;  page-no=&quot;+i+ &quot;&gt;&quot;+(i+1)+&quot;&lt;/li&gt;&quot;); // 自定义属性current-page表示当前页 ，page-no表示该页码按钮控制跳转到第几页        else            $(&#39;#page&#39;).append(&quot;&lt;li current-page=&quot;+page+&quot;  page-no=&quot;+i+ &quot;&gt;&quot;+(i+1)+&quot;&lt;/li&gt;&quot;);    }}// 为页码按钮，上一页下一页添加事件$(&#39;#page&#39;).on(&#39;click&#39;,&#39;li&#39;,function(e){        var currentPage = Number($(this).attr(&#39;current-page&#39;));        var page = Number($(this).attr(&#39;page-no&#39;));        var params = {            page:page,            size:10        }        if(currentPage!==page){ //判断点击的这一页是否为当前页，如果不是则执行跳页操作            $(&quot;#page li&quot;).removeClass(&#39;active&#39;);            $(this).addClass(&#39;active&#39;);            getNotices(params);        }    })    $(&#39;#next&#39;).on(&#39;click&#39;,function(e){        var totalPages = Number($(this).attr(&#39;total-pages&#39;));        var currentPage = Number($($(&#39;#page li&#39;)[0]).attr(&#39;current-page&#39;));        if(currentPage&lt;(totalPages-1)){ // 判断当前页是否为最后一页，如果否则执行下一页操作            var params = {                page:currentPage+1,                size:10            }            getNotices(params);        }    })    $(&#39;#prev&#39;).on(&#39;click&#39;,function(e){        var currentPage = Number($($(&#39;#page li&#39;)[0]).attr(&#39;current-page&#39;));        if(currentPage&gt;0){ // 判断当前页是否为第一页，如果否则执行上一页操作            var params = {                page:currentPage-1,                size:10            }            getNotices(params);        }    })</code></pre><script type="text/javascript" src="/js/src/bai.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;一直在写vue和react的项目，习惯了有组件的快乐生活，近期突然项目上让去写一个jQuery模块，一脸懵逼，jQuery是啥？分页？果然生于忧患，死于安乐呀，赶紧写个分页小demo压压惊&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="jQuery" scheme="https://www.zhangyongxuan.com/categories/jQuery/"/>
    
    
      <category term="前端" scheme="https://www.zhangyongxuan.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="jQuery" scheme="https://www.zhangyongxuan.com/tags/jQuery/"/>
    
      <category term="分页" scheme="https://www.zhangyongxuan.com/tags/%E5%88%86%E9%A1%B5/"/>
    
      <category term="ajax" scheme="https://www.zhangyongxuan.com/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>cookie</title>
    <link href="https://www.zhangyongxuan.com/2021/08/22/cookie/"/>
    <id>https://www.zhangyongxuan.com/2021/08/22/cookie/</id>
    <published>2021-08-22T07:34:03.000Z</published>
    <updated>2021-11-10T06:34:24.296Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><em>由于HTTP协议是无状态的，而服务器端的业务必须是要有状态的。Cookie诞生的最初目的是为了存储web中的状态信息，以方便服务器端使用。比如判断用户是否是第一次访问网站。目前最新的规范是RFC 6265，它是一个由浏览器服务器共同协作实现的规范。</em></strong><br><a id="more"></a></p><h1 id="Cookie的工作流程"><a href="#Cookie的工作流程" class="headerlink" title="Cookie的工作流程"></a>Cookie的工作流程</h1><p>cookie通常是由后端服务器生成，当浏览器向后端服务器发送请求的时候，后端服务器向相应头写入cookie，浏览器接收到这个带着cookie信息的相应时就会把cookie存在本地磁盘的某个地方，当该页面下一次向服务器发送请求的时候，就会自动带上这个cookie信息，cookie都有过期事件，当cookie过期之后，浏览器就会将该条cookie信息删除。<br>简单来说工作流程就是如下：</p><pre><code>server(set-cookie)--(cookie)--&gt;Browser--(cookie)--&gt;server</code></pre><p>通常被用来做通用登录验证，防止XSS(跨站脚本攻击)</p><h1 id="服务器端的发送与解析"><a href="#服务器端的发送与解析" class="headerlink" title="服务器端的发送与解析"></a>服务器端的发送与解析</h1><ul><li><h2 id="发送cookie"><a href="#发送cookie" class="headerlink" title="发送cookie"></a>发送cookie</h2>服务器端像客户端发送Cookie是通过HTTP响应报文实现的，在Set-Cookie中设置需要像客户端发送的cookie，cookie格式如下：<pre><code>Set-Cookie: &quot;name=value;domain=.domain.com;path=/;expires=Sat, 11 Jun 2016 11:29:42 GMT;HttpOnly;secure&quot;</code></pre></li><li>name : 一个唯一确定的cookie名称。通常来讲cookie的名称是不区分大小写的</li><li>value : 存储在cookie中的字符串值。最好为cookie的name和value进行url编码</li><li>demain ： cookie对于哪个域是有效的。所有向该域发送的请求中都会包含这个cookie信息。这个值可以包含子域(如：yq.aliyun.com)，也可以不包含它(如：.aliyun.com，则对于aliyun.com的所有子域都有效).</li><li>path: 表示这个cookie影响到的路径，浏览器跟会根据这项配置，像指定域中匹配的路径发送cookie。</li><li>expires:失效时间，表示cookie何时应该被删除的时间戳(也就是，何时应该停止向服务器发送这个cookie)。如果不设置这个时间戳，浏览器会在页面关闭时即将删除所有cookie；不过也可以自己设置删除时间。这个值是GMT时间格式，如果客户端和服务器端时间不一致，使用expires就会存在偏差。</li><li>HttpOnly: 告知浏览器不允许通过脚本document.cookie去更改这个值，同样这个值在document.cookie中也不可见。但在http请求张仍然会携带这个cookie。注意这个值虽然在脚本中不可获取，但仍然在浏览器安装目录中以文件形式存在。这项设置通常在服务器端设置。</li><li>secure: 安全标志，指定后，只有在使用SSL链接时候才能发送到服务器，如果是http链接则不会传递该信息。就算设置了secure 属性也并不代表他人不能看到你机器本地保存的 cookie 信息，所以不要把重要信息放cookie就对了服务器端设置</li></ul><p>设置cookie的例子：</p><pre><code>var http = require(&#39;http&#39;);var fs = require(&#39;fs&#39;);http.createServer(function(req, res) {  res.setHeader(&#39;status&#39;, &#39;200 OK&#39;);  res.setHeader(&#39;Set-Cookie&#39;, &#39;isVisit=true;domain=.yourdomain.com;path=/;max-age=1000&#39;);  res.write(&#39;Hello World&#39;);  res.end();}).listen(8888);console.log(&#39;running localhost:8888&#39;) </code></pre><p>可以对设置cookie进行一层封装</p><pre><code>const setCookie = (name,value,options)=&gt;{    if (!name) {    throw new Error(&quot;coolie must have name&quot;);    }    const enc = encodeURIComponent;    const part = [];    val = (val !== null &amp;&amp; val !== undefined) ? val.toString() : &quot;&quot;;    options = options||{};    part.push(`${enc(name)}=${enc(value)}`);    options.domain&amp;&amp;part.push(`domian=${options.domain}`);     if (options.path) {    parts.push(&quot;path=&quot; + options.path);    }    // 如果不设置expires和max-age浏览器会在页面关闭时清空cookie    if (options.expires) {      parts.push(&quot;expires=&quot; + options.expires.toGMTString());    }    if (options.maxAge &amp;&amp; typeof options.maxAge === &quot;number&quot;) {      parts.push(&quot;max-age=&quot; + options.maxAge);    }    if (options.httpOnly) {      parts.push(&quot;HTTPOnly&quot;);    }    if (options.secure) {      parts.push(&quot;secure&quot;);    }    return parts.join(&quot;;&quot;);}</code></pre><p>这里要注意的一点是,对cookie的操作并没有删除，当我们需要删除一条cookie记录的时候只需要将它的有效时间设置为一个过去的时间，这条数据就会被删除。还有就是domain项必须有两个点，因此不能设置为localhost:</p><pre><code>something that wasn&#39;t made clear to me here and totally confused me for a while was that domain name</code></pre><ul><li><h2 id="服务端解析cookie"><a href="#服务端解析cookie" class="headerlink" title="服务端解析cookie"></a>服务端解析cookie</h2></li></ul><p>cookie可以设置不同的域与路径，所以对于同一个name value，在不同域不同路径下是可以重复的，浏览器会按照与当前请求url或页面地址最佳匹配的顺序来排定先后顺序，所以当前端传递到服务器端的cookie有多个重复name value时，我们只需要最匹配的那个，也就是第一个。服务器端解析代码如下：</p><pre><code>var parse = function(cstr) {  if (!cstr) {    return null;  }  var dec = decodeURIComponent;  var cookies = {};  var parts = cstr.split(/\s*;\s*/g);  parts.forEach(function(p){    var pos = p.indexOf(&#39;=&#39;);    // name 与value存入cookie之前，必须经过编码    var name = pos &gt; -1 ? dec(p.substr(0, pos)) : p;    var val = pos &gt; -1 ? dec(p.substr(pos + 1)) : null;    //只需要拿到最匹配的那个    if (!cookies.hasOwnProperty(name)) {      cookies[name] = val;    }/* else if (!cookies[name] instanceof Array) {      cookies[name] = [cookies[name]].push(val);    } else {      cookies[name].push(val);    }*/  });  return cookies;}</code></pre><ul><li><h2 id="客户端的存取"><a href="#客户端的存取" class="headerlink" title="客户端的存取"></a>客户端的存取</h2>浏览器将后台传递过来的cookie进行管理，并且允许开发者在JavaScript中使用document.cookie来存取cookie。但是这个接口使用起来非常蹩脚。它会因为使用它的方式不同而表现出不同的行为。<br>当用来获取属性值时，document.cookie返回当前页面可用的（根据cookie的域、路径、失效时间和安全设置）所有的字符串，字符串的格式如下：</li></ul><pre><code>&quot;name1=value1;name2=value2;name3=value3&quot;;</code></pre><p>设置document.cookie并不会覆盖cookie，除非设置的name value domain path都与一个已存在cookie重复。<br>由于cookie的读写非常不方便，我们可以自己封装一些函数来处理cookie，主要是针对cookie的添加、修改、删除。</p><pre><code>var cookieUtils = {    get: function(name){     var cookieName=encodeURIComponent(name) + &quot;=&quot;;     //只取得最匹配的name，value     var cookieStart = document.cookie.indexOf(cookieName);     var cookieValue = null;     if (cookieStart &gt; -1) {      // 从cookieStart算起      var cookieEnd = document.cookie.indexOf(&#39;;&#39;, cookieStart);      //从=后面开始      if (cookieEnd &gt; -1) {       cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd));      } else {       cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, document.cookie.length));      }     }     return cookieValue;    },    set: function(name, val, options) {      if (!name) {        throw new Error(&quot;coolie must have name&quot;);      }      var enc = encodeURIComponent;      var parts = [];      val = (val !== null &amp;&amp; val !== undefined) ? val.toString() : &quot;&quot;;      options = options || {};      parts.push(enc(name) + &quot;=&quot; + enc(val));      // domain中必须包含两个点号      if (options.domain) {        parts.push(&quot;domain=&quot; + options.domain);      }      if (options.path) {        parts.push(&quot;path=&quot; + options.path);      }      // 如果不设置expires和max-age浏览器会在页面关闭时清空cookie      if (options.expires) {        parts.push(&quot;expires=&quot; + options.expires.toGMTString());      }      if (options.maxAge &amp;&amp; typeof options.maxAge === &quot;number&quot;) {        parts.push(&quot;max-age=&quot; + options.maxAge);      }      if (options.httpOnly) {        parts.push(&quot;HTTPOnly&quot;);      }      if (options.secure) {        parts.push(&quot;secure&quot;);      }      document.cookie = parts.join(&quot;;&quot;);    },    delete: function(name, options) {     options.expires = new Date(0);// 设置为过去日期     this.set(name, null, options);    }   }</code></pre><p>更多详细内容在原文<br><a href="https://www.jb51.net/article/86598.htm?pc" target="_blank" rel="noopener">点我查看原文</a></p><script type="text/javascript" src="/js/src/bai.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;由于HTTP协议是无状态的，而服务器端的业务必须是要有状态的。Cookie诞生的最初目的是为了存储web中的状态信息，以方便服务器端使用。比如判断用户是否是第一次访问网站。目前最新的规范是RFC 6265，它是一个由浏览器服务器共同协作实现的规范。&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Cookie" scheme="https://www.zhangyongxuan.com/categories/Cookie/"/>
    
    
      <category term="服务端" scheme="https://www.zhangyongxuan.com/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
      <category term="node" scheme="https://www.zhangyongxuan.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>less</title>
    <link href="https://www.zhangyongxuan.com/2021/07/26/less/"/>
    <id>https://www.zhangyongxuan.com/2021/07/26/less/</id>
    <published>2021-07-26T06:11:47.000Z</published>
    <updated>2021-11-10T06:34:24.291Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><em>css预处理器用一种专门的编程语言，为css增加一些编程语言的特性，例如在css中使用变量、简单的逻辑程序、函数等等。而且还能让css可读性更佳，代码更易于维护。</em></strong></p><a id="more"></a><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><p>css不是编程语言，它没有变量，函数，条件语句等语法，只是一群简单的属性描述，代码不利于维护和扩展。</p><h2 id="css预处理器"><a href="#css预处理器" class="headerlink" title="css预处理器"></a>css预处理器</h2><p>css预处理器用一种专门的编程语言，为css增加一些编程语言的特性，例如在css中使用变量、简单的逻辑程序、函数等等。而且还能让css可读性更佳，代码更易于维护。</p><h2 id="常用的css预处理器"><a href="#常用的css预处理器" class="headerlink" title="常用的css预处理器"></a>常用的css预处理器</h2><p> 最好用的两个，sass和less。</p><h2 id="less的使用"><a href="#less的使用" class="headerlink" title="less的使用"></a>less的使用</h2><ul><li><p>安装</p><pre><code>npm i less-loader less --save-dev</code></pre></li><li><p>在webpack中配置</p></li></ul><pre><code>{    test : /\.less$/,    user : [{        loader : &#39;style-loader&#39;    },]    user : [{        loader : &#39;css-loader&#39;    },]    user : [{        loader : &#39;less-loader&#39;    },]}</code></pre><ul><li>新建后缀为.less的文件，然后在页面中引用：<pre><code>import &#39;./style/index.less</code></pre><h2 id="less的语法"><a href="#less的语法" class="headerlink" title="less的语法"></a>less的语法</h2></li><li>变量：<br>使用@+变量名的方式定义变量，使用变量时在变量名前加@<pre><code>@size : 20px;.box{  font-size : @siza}</code></pre></li><li>混合:<br>将一些通用的属性集合用class封装起来，然后在另一个class中去引用这个class下的所有属性。当然，除了class，id属性集也可以以相同的方式引用。<pre><code>.cla1{  color:red;}.cla2{  .cla1;}</code></pre></li><li>带参数混合:<br>在less中，你还可以像函数一样定义一个带参数的属性集合<pre><code>.clas(@color){  color:@color;}.box{  .cla(&#39;red&#39;)}</code></pre>@arguments变量，包含了所有传进来的参数，如果你不想单独处理每一个参数的话可以像这样写：<pre><code>.box(@x:0,@y:0,@color){   width:@arguments;   height :@arguments;   color : @arguments;}</code></pre></li><li>嵌套:<br>为了让css代码简洁清晰，易维护，现在less允许我们以嵌套的方式编写层叠样式，子元素样式可以直接嵌套在父元素样式中：</li></ul><pre><code>.box{    .smallbox{    }}</code></pre><ul><li>运算:<br>在less中，任何数字、颜色或者变量都可以参与运算。</li></ul><pre><code>@basewidth:20px;.cl{    width : @basewidth*2;}</code></pre><script type="text/javascript" src="/js/src/bai.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;css预处理器用一种专门的编程语言，为css增加一些编程语言的特性，例如在css中使用变量、简单的逻辑程序、函数等等。而且还能让css可读性更佳，代码更易于维护。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="css" scheme="https://www.zhangyongxuan.com/categories/css/"/>
    
    
      <category term="css" scheme="https://www.zhangyongxuan.com/tags/css/"/>
    
      <category term="less" scheme="https://www.zhangyongxuan.com/tags/less/"/>
    
  </entry>
  
  <entry>
    <title>鹏哥的webpack笔记</title>
    <link href="https://www.zhangyongxuan.com/2021/07/25/webpacksimple/"/>
    <id>https://www.zhangyongxuan.com/2021/07/25/webpacksimple/</id>
    <published>2021-07-25T09:50:35.000Z</published>
    <updated>2021-11-10T06:34:24.295Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><em>鹏哥是本人react和webpack入门的领路人</em></strong></p><a id="more"></a><h1 id="什么是webpack？"><a href="#什么是webpack？" class="headerlink" title="什么是webpack？"></a>什么是webpack？</h1><p>据个人理解，webpack就是一个组织工具，它可以根据一些配置，组织一个前端项目，让开发者可以使用一些浏览器不支持的技术，比如模板技术（vue，react），es6语法，less，sass方便开发。</p><h1 id="webpack主要完成的工作"><a href="#webpack主要完成的工作" class="headerlink" title="webpack主要完成的工作"></a>webpack主要完成的工作</h1><p> webpack主要为前端开发者提供一些服务：</p><ul><li>本地开发环境热更新服务。这个服务提供一个本地服务器，可以实时的看到我们对项目代码的修改在页面上的体现，相当于vscode对markdown文件的预览一样。</li><li>代理服务。目前的项目基本都是前后端分离开发，前端一个服务器，后端一个服务器，这时候就会产生跨域的问题，这个服务就是为了解决跨域的问题，提供了请求转发的服务。</li><li>编译服务。目前浏览器对es6，sass，less的支持并不是很好，跟别说vue，react这样的框架了，这就像抗日战争的时候，小日本帝国来我们大中国需要找一个翻译官来负责翻译一样，这些文件也需要一个翻译官，来将他们翻译成浏览器能看得懂的代码，webpack就提供了这样的翻译服务。</li><li>压缩打包服务。这个服务顾名思义，它的作用就是打包了，打包的同时它还可以有效的压缩文件。</li></ul><h1 id="这些服务具体是在构建中的哪个环节被处理？"><a href="#这些服务具体是在构建中的哪个环节被处理？" class="headerlink" title="这些服务具体是在构建中的哪个环节被处理？"></a>这些服务具体是在构建中的哪个环节被处理？</h1><ul><li>如果与输入相关的需求，找entry（比如多页面就有多个入口）</li><li>如果与输出相关的需求，找output（比如你需要定义输出文件的路径、名字等等）</li><li>如果与模块寻址相关的需求，找resolve（比如定义别名alias）</li><li>如果与转译相关的需求，找loader（比如处理sass处理es678N）</li><li>如果与构建流程相关的需求，找plugin（比如我需要在打包完成后，将打包好的文件复制到某个目录，然后提交到git上）</li></ul><p>由此看来，我们的webpack配置可以按需配置，就是用到什么配置什么。</p><h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><h2 id="webpack-安装"><a href="#webpack-安装" class="headerlink" title="webpack 安装"></a>webpack 安装</h2><ul><li>yarn add webpcak webpack-cli //安装 webpack4.X 还需要一个需要 webpack-cli</li><li>webpack.config.js</li><li>npx webpack 局部执行 webpack，解决了多版本 webpack 共存</li></ul><h2 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h2><h4 id="文件输出配置"><a href="#文件输出配置" class="headerlink" title="文件输出配置"></a>文件输出配置</h4><pre><code>npx webpack --config webpack.config.js //可以更换默认配置文件</code></pre><pre><code>const path =require(&#39;path&#39;); //引入path模块path.resolve(__dirname,&#39;dist&#39;); //__dirname根目录，配置绝对路径 输出文件目录</code></pre><pre><code>mode: &#39;development&#39;,//设置环境&#39;production&#39;/&#39;development&#39;devtool: &#39;source-map&#39;, // 源码映射直接显示源码错误位置// build=&gt; &#39;source-map&#39;打包速度-- 生成app.js.map映射文件 &#39;inline-source-map&#39; 以dataurl的方式直接写在app.js</code></pre><pre><code>&quot;scripts&quot;: {    &quot;build&quot;: &quot;webpack&quot; //优先执行工程下webpack版本，类似npx  },</code></pre><h4 id="模块配置"><a href="#模块配置" class="headerlink" title="模块配置"></a>模块配置</h4><pre><code>module:{  rules:[    {},{},{} //处理不同类型文件  ]}</code></pre><h4 id="核心文件配置"><a href="#核心文件配置" class="headerlink" title="核心文件配置"></a>核心文件配置</h4><ol><li>处理图片或字体</li></ol><ul><li>安装 file-loader<pre><code>npm install --save-dev file-loader</code></pre></li><li>配置<pre><code>module: {    rules: [      {        test: /\.(eot|ttf|svg)$/,        use: [          {            loader: &#39;file-loader&#39;,            options: {              name: &#39;static/[name].[ext]&#39;,// 自定义文件name            }          }        ]      }    ]  }</code></pre></li><li>安装 url-loader<pre><code>npm install url-loader --save-dev</code></pre></li><li>配置(默认转换成 base64 形式打包到 js 中)<pre><code>rules: [  {    test: /\.(png|jpg|gif)$/i,    use: [      {        loader: &#39;url-loader&#39;,        options: {          limit: 8192 //设置大小(b)，超出则打包成图片文件，没超过就转换成base64字符串加载到js中        }      }    ]  }]</code></pre></li></ul><ol start="2"><li>处理 vue 文件</li></ol><ul><li>安装–将 vue-loader 和 vue-template-compiler 一起安装<pre><code>npm install -D vue-loader vue-template-compiler</code></pre></li><li>配置<pre><code>module: {  rules: [    {      test: /\.vue$/,      use: [&#39;vue-loader&#39;]    }  ]},plugins: [  // 请确保引入这个插件！  new VueLoaderPlugin()]</code></pre></li></ul><ol start="3"><li>处理 css 文件</li></ol><ul><li>安装<pre><code>yarn add style-loader css-loader -D</code></pre></li><li>配置<pre><code>{  test: /\.css$/,  use: [    {    loader: &#39;css-loader&#39;,    options: {      modules: true, // 开启 css-module    }  ]</code></pre></li></ul><ol start="4"><li>处理 less 文件</li></ol><ul><li>安装<pre><code>yarn add less-loader less -D</code></pre></li><li>配置<pre><code>{  test: /\.less$/,  use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;] // loader执行顺序是从下到上，从左到右}</code></pre></li></ul><ol start="5"><li>处理 sass 文件</li></ol><ul><li>安装<pre><code>yarn add sass-loader node-sass -D</code></pre></li><li>配置<pre><code>{  test: /\.scss$/,  use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;] // loader执行顺序是从下到上，从左到右},</code></pre></li></ul><ol start="6"><li>抽离 css</li></ol><pre><code>const ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);{//配置css      test: /\.css$/,      use: ExtractTextPlugin.extract({              fallback: &quot;style-loader&quot;,              use: &quot;css-loader&quot;      })    },//处理css文件new ExtractTextPlugin(&quot;css/[name].css&quot;),</code></pre><ol start="7"><li>编译 es6<br>babel-loader @babel/core 还要@babel/preset-env</li></ol><pre><code>{      test: /\.m?js$/,      exclude: /(node_modules|bower_components)/,      use: {        loader: &quot;babel-loader&quot;,        options: {          presets: [&quot;@babel/preset-env&quot;]        }      }    },    import &quot;@babel/polyfill&quot;; // 打包变大，=》变量实现    presets: [[&quot;@babel/preset-env&quot;, {              &quot;useBuiltIns&quot;: &quot;usage&quot;            }]] // 只补充当前使用</code></pre><ol start="8"><li>打包react   @babel/preset-react</li></ol><pre><code>presets: [&quot;@babel/preset-env&quot;, &quot;@babel/preset-react&quot;]</code></pre><h4 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h4><ol><li>HtmlWebpackPlugin</li></ol><ul><li>yarn add html-webpack-plugin</li><li>配置</li></ul><pre><code>const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);const path = require(&#39;path&#39;);module.exports = {  entry: &#39;index.js&#39;,  output: {    path: path.resolve(__dirname, &#39;./dist&#39;),    filename: &#39;index_bundle.js&#39;  },  plugins: [new HtmlWebpackPlugin()]};</code></pre><ol start="2"><li>CleanWebpackPlugin</li></ol><ul><li>yarn add clean-webpack-plugin</li><li>配置</li></ul><pre><code>new CleanWebpackPlugin([&#39;dist&#39;], { //第一个是填写要删除的路径，格式是个数组 //第二个参数是对象类型的配置    root: path.resolve(__dirname, &#39;..&#39;), // root：绝对路径，就是要根据这个root去找要删除的文件夹    dry: false // 启用删除文件 //为false是删除文件夹的，为true是不删除的，默认值是false  }),</code></pre><ol start="3"><li>HtmlWebpackPlugin</li></ol><pre><code>const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);new HtmlWebpackPlugin({      template: &quot;./src/app.html&quot;,      filename: &quot;index.html&quot;,      title: &quot;webpack&quot;,      inject: true, // true || &#39;head&#39; || &#39;body&#39; || false将所有资产注入给定template或templateContent。传递true或&#39;body&#39;所有javascript资源将被放置在body元素的底部。&#39;head&#39;将脚本放在head元素中      hash: true,      chunks: [&quot;commons&quot;, name], // 允许您仅添加一些块（例如，仅添加单元测试块）      // favicon: &quot;./favicon.ico&quot;    }),</code></pre><h3 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h3><ol><li><p>webpack –watch</p></li><li><p>webpack-dev-server</p></li></ol><pre><code>devServer: {  contentBase: &#39;./dist&#39;,  port: 8008,  open: true,  proxy: {      &quot;/weatherApi&quot;: {        target: &quot;https://www.apiopen.top&quot;,        changeOrigin: true      }    },  hot: true, // HMR热更新  hotOnly: true,  if (module.hot) {    module.hot.accept(&#39;&#39;, function(){    })  }}</code></pre><h3 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h3><pre><code>  optimization: {    minimize: true, // 压缩    usedExport: true, // 只打包export Tree shaking  },</code></pre><h3 id="config合并"><a href="#config合并" class="headerlink" title="config合并"></a>config合并</h3><pre><code>const merge=require(&#39;webpack-merge&#39;);const commonConfig={}const devConfig={}module.exports= merge(commonConfig, devConfig);</code></pre><h3 id="配置引用路径"><a href="#配置引用路径" class="headerlink" title="配置引用路径"></a>配置引用路径</h3><pre><code>resolve:{      alias:{          style: path.resolve(__dirname, &#39;./src/static/style&#39;),      }  },</code></pre><script type="text/javascript" src="/js/src/bai.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;鹏哥是本人react和webpack入门的领路人&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="webpack" scheme="https://www.zhangyongxuan.com/categories/webpack/"/>
    
    
      <category term="前端" scheme="https://www.zhangyongxuan.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="webpack" scheme="https://www.zhangyongxuan.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack纯手工搭建react项目</title>
    <link href="https://www.zhangyongxuan.com/2021/07/25/webpack-react/"/>
    <id>https://www.zhangyongxuan.com/2021/07/25/webpack-react/</id>
    <published>2021-07-25T09:42:14.000Z</published>
    <updated>2021-11-10T06:34:24.294Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><em>使用webpack从0搭建一个react项目</em></strong></p><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>第一步就是安装，安装什么呢？安装webpack，如果是webpack4.x版本的话还需要安装一个webpack-cli,新建文件夹，在文件夹里创建package.json文件，很简单，在文件夹下打开cmd，运行下面这两条命令就完成了。</p><pre><code>npm inityarn add webpack webpack-cli</code></pre><p>这里运行<code>npm init</code>的时候一路回车就ok了。</p><h3 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h3><ul><li>在根目录下新建配置文件：<code>webpack.config.js</code><br>这个文件名是webpack默认的配置文件，如果直接使用打包命令<code>npx webpack</code>或者<code>webpack</code>来执行打包的话，就会默认以这个文件中的配置执行打包，既然是默认的，当然可以自己改变这个文件了，如果配置文件为<code>config.js</code>的话可以使用下边这个命令：<pre><code>  npx webpack --config config.js </code></pre></li><li><p>配置入口文件，输出文件以及模式：</p><pre><code>  const path = require(&#39;path&#39;);//这里导入nodejs的path模块  module.exports = {      mode : &#39;development&#39;, //指定打包模式  &#39;production&#39;/&#39;development&#39;      entry : &#39;./src/index.js&#39;, //指定打包的入口文件 写相对路径      devtool: &#39;inline-source-map&#39;, // 源码映射直接显示源码错误位置      // build=&gt; &#39;source-map&#39;打包速度-- 生成app.js.map映射文件 &#39;inline-source-map&#39; 以dataurl的方式直接写在app.js      output : {          path : path.resolve(__dirname,&#39;dist&#39;),//这里是指定打包之后的文件存放路径          //这里的__dirname是nodejs中的一个全局变量，它的值就是当前运行脚本所在路径          filename : &#39;index.js&#39; //这是指定打包的index.js在上边路径里的文件名      }   }    </code></pre><p>  到这里，一个最基础的webpack配置文件就完成了，运行<code>npx webpack</code>就能在根目录下看到一个dist文件夹，里面有index.js</p><p>  配置打包命令：</p><pre><code>  .....  &quot;script&quot; : {      &quot;build&quot; : &quot;webpack&quot;  }  .....</code></pre><p>  配置完之后就可以使用<code>npm run build</code>直接进行打包了</p></li><li><p>配置开发环境服务器：</p><p>  首先安装<code>webpack-dev-server</code></p><pre><code>  cnpm i webpack-dev-server --save-dev</code></pre><pre><code>      devServer:{ //配置前端服务器，方便开发          contentBase : &#39;./public&#39;, //文件暂存区          port : 9000, //服务器端口号          hot : true, //启用模块热更新          open : true, //服务器启动完成之后在默认浏览器打开index.html          proxy:{ //为请求的接口配置代理服务器          }      }   </code></pre><p>  然后在package.json中去配置：</p><pre><code>  ....  &quot;scripts&quot;: {      &quot;build&quot; : &quot;webpack&quot;, //一键打包      &quot;start&quot;: &quot;webpack-dev-server&quot; //一键启动开发服务器  },  ....</code></pre><p>  这个时候使用命令<code>npm start</code>就可以启动这个开发服务器了</p></li><li><p>配置css模块和html模块：</p><p>   无论是什么框架的项目，只要是个前端项目必然会使用层叠样式表和html，也就是我们要为这个项目的webpack赋予组织.css文件和.html的文件，首先我们在src下创建index.css和index.html</p><p>  首先还是安装：</p><pre><code>  cnpm install --save-dev html-webpack-plugin //这是一个插件，配置完之后会根据自己的配置，将html页面打包进去  cnpm install --save-dev css-loader style-loader //这是处理css文件的两个加载器</code></pre><p>  这里使用淘宝镜像可以提高下载速度</p><p>  在module下的rules中配置css-loader，这将赋予这个项目组织.css文件的能力</p><pre><code>  {      test: /\.css$/i, //检测.css结尾的文件      use: [&#39;style-loader&#39;, &#39;css-loader&#39;], //决定使用什么样的加载器  },</code></pre><p>  配置html插件</p><pre><code>      const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); //导入html的插件      ....      plugins: [new HtmlWebpackPlugin()]   </code></pre><p>  配置完这两项之后，在打包就会发现，html文件也被打包到dist文件夹里</p></li><li><p>配置babel和react模块：</p><p>  babel是一个用来编译es6代码的工具，浏览器识别不了一些es6语法，而react中到处是es6语法，所以就要使用babel模块赋予这个项目组织react和es6的能力。</p><p>  首先配置babel：</p><p>  安装：</p><pre><code>  cnpm install -D babel-loader @babel/core @babel/preset-env webpack</code></pre><p>  添加匹配规则：</p><pre><code>  {      test: /\.m?js$/, //匹配.js文件      exclude: /(node_modules|bower_components)/, //这里表示忽略node_modules|bower_components下的.js文件      use: {          loader: &#39;babel-loader&#39;,          options: {          presets: [&#39;@babel/preset-env&#39;]          }      }  },</code></pre><p>  配置react ：</p><pre><code>  presets: [&quot;@babel/preset-env&quot;, &quot;@babel/preset-react&quot;]</code></pre><p>  这时候这个项目已经有了编译react的能力</p></li><li><p>配置路径别名：<br>  当我们的项目目录比较复杂的时候我们可以使用alias配置别名</p><pre><code>  resolve:{    alias:{ //为复杂的路径配置别名      &#39;style&#39;: path.resolve(__dirname, &#39;./src/assets/style&#39;),      &#39;@&#39;: path.resolve(__dirname, &#39;./src&#39;),    }  },   </code></pre></li></ul><h3 id="到这里，一个完全手工搭建的react项目就完成了，webpack配置文件如下："><a href="#到这里，一个完全手工搭建的react项目就完成了，webpack配置文件如下：" class="headerlink" title="到这里，一个完全手工搭建的react项目就完成了，webpack配置文件如下："></a>到这里，一个完全手工搭建的react项目就完成了，webpack配置文件如下：</h3><pre><code>const path = require(&#39;path&#39;);//这里导入nodejs的path模块const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); //导入html的插件const {CleanWebpackPlugin} = require(&#39;clean-webpack-plugin&#39;);module.exports = {    mode : &#39;development&#39;, //指定打包模式  &#39;production&#39;/&#39;development&#39;    entry : &#39;./src/index.js&#39;, //指定打包的入口文件 写相对路径    devtool: &#39;inline-source-map&#39;, // 源码映射直接显示源码错误位置    // build=&gt; &#39;source-map&#39;打包速度-- 生成app.js.map映射文件 &#39;inline-source-map&#39; 以dataurl的方式直接写在app.js    output : {        path : path.resolve(__dirname,&#39;dist&#39;),//这里是指定打包之后的文件存放路径，这里的__dirname是nodejs中的一个全局变量，它的值就是当前运行脚本所在路径        filename : &#39;index.js&#39; //这是指定打包的index.js在上边路径里的文件名    },    module : {         rules: [            {              test: /\.css$/i, //匹配.css结尾的文件              use: [&#39;style-loader&#39;, &#39;css-loader&#39;], //决定使用什么样的加载器            },            {                test: /\.m?js$/, //匹配.js文件                exclude: /(node_modules|bower_components)/, //这里表示忽略node_modules|bower_components下的.js文件                use: {                  loader: &#39;babel-loader&#39;,                  options: {                    presets: [&#39;@babel/preset-env&#39;,&#39;@babel/preset-react&#39;]                  }                }            },          ],    },    plugins: [        new HtmlWebpackPlugin({          template : &#39;./src/index.html&#39;        }),//添加插件，多页面也有多页面的配置方法，现在搭建一个react spa就不需要过多的配置        new CleanWebpackPlugin()    ],    devServer:{ //配置前端服务器，方便开发        contentBase : &#39;./public&#39;, //文件暂存区        port : 9000, //服务器端口号        hot : true, //启用模块热更新        open : true, //服务器启动完成之后在默认浏览器打开index.html        proxy:{ //为请求的接口配置代理服务器        }    },    resolve:{      alias:{ //为复杂的路径配置别名        &#39;style&#39;: path.resolve(__dirname, &#39;./src/assets/style&#39;),        &#39;@&#39;: path.resolve(__dirname, &#39;./src&#39;),      }    },   }</code></pre><script type="text/javascript" src="/js/src/bai.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;使用webpack从0搭建一个react项目&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="webpack" scheme="https://www.zhangyongxuan.com/categories/webpack/"/>
    
    
      <category term="react" scheme="https://www.zhangyongxuan.com/tags/react/"/>
    
      <category term="前端" scheme="https://www.zhangyongxuan.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="webpack" scheme="https://www.zhangyongxuan.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Dva入门</title>
    <link href="https://www.zhangyongxuan.com/2021/07/24/dva1/"/>
    <id>https://www.zhangyongxuan.com/2021/07/24/dva1/</id>
    <published>2021-07-24T15:22:43.000Z</published>
    <updated>2021-11-10T06:34:24.249Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><em>对于Dva我的理解是这样的：Dva重新组织了react项目，内置了react-router，redux，request，减少了配置这些模块的代码，将程序猿的精力都留给处理业务逻辑 </em></strong></p><a id="more"></a><h1 id="什么是Dva"><a href="#什么是Dva" class="headerlink" title="什么是Dva"></a>什么是Dva</h1><blockquote><p>Dva基于现有应用架构 (redux + react-router + redux-saga 等)的一层轻量封装，没有引入任何新概念，全部代码不到 100 行。</p></blockquote><p>这是Dva官方文档中对它的介绍，我的理解是这样的：</p><p>Dva重新组织了react项目，内置了react-router，redux，request，减少了配置这些模块的代码，将程序猿的精力都留给处理业务逻辑。</p><p>使用Dva非常简单，首先通过 npm 安装 dva-cli 并确保版本是 0.9.1 或以上。</p><pre><code>$ npm install dva-cli -g$ dva -vdva-cli version 0.9.1</code></pre><p>安装完 dva-cli 之后，就可以在命令行里访问到 dva 命令（不能访问？）。现在，你可以通过 dva new 创建新应用。</p><pre><code>$ dva new dva-quickstart</code></pre><p>这会创建 dva-quickstart 目录，包含项目初始化目录和文件，并提供开发服务器、构建脚本、数据 mock 服务、代理服务器等功能。</p><p>然后我们 cd 进入 dva-quickstart 目录，并启动开发服务器：</p><pre><code>$ cd dva-quickstart$ npm start</code></pre><p>之后就会自打开系统默认浏览器，并访问<code>http://localhost:8000/</code>,只是后就能看到dva的欢迎页面了</p><h1 id="dva中的数据流向，以及dva脚手架搭建的项目目录结构"><a href="#dva中的数据流向，以及dva脚手架搭建的项目目录结构" class="headerlink" title="dva中的数据流向，以及dva脚手架搭建的项目目录结构"></a>dva中的数据流向，以及dva脚手架搭建的项目目录结构</h1><h2 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h2><p><a href="https://blog.csdn.net/wangrong111222/article/details/79835490" target="_blank" rel="noopener">原文地址</a></p><blockquote><p>项目中一般src里的目录标配：</p><ul><li>./assets   :放置静态资源 比如图片;</li><li>./components   :放置木偶组件，只负责从./routes的智能组件来读取props填充展示，一般来讲是纯函数的react书写方式;</li><li>./models   :是一个处理数据的地方，比如在model里面调用./service输出的方法来获取数据填充到store;其实我觉得就是store的整体的集合，以 namespace作为唯一标识进行区分；</li><li>./routes   :放置若干智能组件的地方，智能组件里一般通过dva的connect（({yourModle})=&gt;({yourModle})）（yourComponent）方法来和你的组件来实现数据互通的，生成带数据的活组件；（一般来讲智能组件的样式也在这级目录，因为组件就近维护原则吧）;</li><li>./services   :负责向后台请求数据，在services里调用后台提供的api获取数据;</li><li>./utils   :放置工具类：比如常见的后台接口请求工具类；这里是默认封装了fetch数据交互的方法，直接入参调用即可;</li><li>index.css   :index.html的样式，你懂的;</li><li>index.js   :主页的入口位置，也是初始化dva的位置；什么 app.use( )/app.model( )/app.router( )/app.start( )都是在这里的完成的;</li><li>index.html   :入口挂载dom的html模板;</li><li>router.js   :配置路由的地方，会从./routes文件夹下引入写好的智能组件来组装页面，export default 出一个方法来生成router结构。</li></ul></blockquote><h1 id="数据流向问题"><a href="#数据流向问题" class="headerlink" title="数据流向问题"></a>数据流向问题</h1><p>数据流向简单来说的话就是：</p><p><code>server----&gt;services----&gt;models----&gt;routes----&gt;components</code></p><p>这样说可能有点过于简单，下面就以获取一个表格数据为例，看看具体数据流向</p><p>多话不说直接上代码：</p><p>首先，我们的表格数据是从后端服务器通过请求接口获取到的，那么上面也说了，<code>services</code>文件夹下的<code>.js</code>文件的任务就是请求接口从后端拿到数据：</p><pre><code>// services/test.jsimport request from &#39;../utils/request&#39; //这里导入dva封装的request模块export function fetchData(){ // 这是一个无参请求的示例                                                                               const url = &#39;xxxxxxxxxx&#39;                           return request(url)}export function fetchData1(params){ // 这是一个带参请求的示例    const url = &#39;xxxxxxxxxx&#39;                           return request(url,{...params})}</code></pre><p>在这里，使用dva封装的request向后端发送请求，接收到数据之后作为函数的返回值return出去。</p><pre><code>// models/test.jsimport {fetchData,fetchData1} from &#39;../services/test&#39;export default {    namespace:&quot;test&quot;,    state:{        data : {},        data1:{}    },    reducers:{        getData:(state,action)=&gt;{ // 这里就和redux的reducer一样，去更新状态            const newState = Object.assign({},state)            // console.log(action)            newState.data = action.value            return newState;         },        getData1:(state,action)=&gt;{            const newState = Object.assign({},state)            // console.log(action)            newState.data1 = action.value            return newState;        }    },    effects:{        *fetchData(action,opr){            const call = opr.call;            const put = opr.put;            const res = yield call(fetchData) //调用services里的函数获得返回值            // console.log(res,111)            const a = {                type:&#39;getData&#39;,                value:res.data            }            yield put(a) //向reducers提交一个action            return res; //这里返回的值会传到dispatch().then()的成功回调参数里        },        *fetchData1(action,opr){            const call = opr.call;            const put = opr.put;            const res = yield call(fetchData1,params) //有参无参区别就在于这里            // console.log(res,111)            const a = {                type:&#39;getData&#39;,                value:res.data            }            yield put(a)            return res;        }    }}</code></pre><p>models层写好了，这里有一步至关重要，那就是去index.js注册这个model：</p><pre><code>index.js// + app.model(require(&#39;./models/test&#39;).default);</code></pre><p>根据刚才所说的数据流向，现在轮到了routes层：</p><pre><code>import React, { Component } from &#39;react&#39;;import {connect} from &#39;dva&#39; //这里导入dva的connect函数class Test extends Component { fetchData=()=&gt;{        const dispatch = this.props.dispatch;        const action = {            type : &#39;test/fetchData&#39;,            value:1        }        dispatch(action).then(res=&gt;{ //这里提交action就和redux一样            console.log(res)        })       }        fetchData1=()=&gt;{        const dispatch = this.props.dispatch;        const action = {            type : &#39;test/fetchData1&#39;,            value:1        }        dispatch(action).then(res=&gt;{            console.log(res)        })       }    render() {        // console.log(this.props)在这里有我们操作全局状态用的dispatch函数以及下边回调函数返回的那些属性名和对应的值        return (            &lt;div&gt;              &lt;Button onClick={()=&gt;{this.fetchData()}}&gt;fetchData&lt;/Button&gt;              &lt;Button onClick={()=&gt;{this.fetchData1()}}&gt;fetchData&lt;/Button&gt;            &lt;/div&gt;        );    }}export default connect(state=&gt;{ //这里的state是全局的state    const data = state.test.data; //每一个model下的namespace在组合的时候变成了一个全局state的一个key，这个key所对应的value就是该namespace下对应的state的值    const data = state.test.data;    const data1 = state.test.data1;    return{ //这个回调函数的返回值会被解构，然后合并到后边括号中组件的props当中        data,        data1    }})(Test); //经过connect包装后，会赋予Test这个组件一些我们要用到的东西// export default Test;</code></pre><p>其实connect函数是一个高阶组件，<a href="http://www.zhangyongxuan.com/2021/07/18/hoc/">点这里复习高阶组件</a></p><p>这样，整个数据流程，从请求数据到数据渲染整个流程就跑完了，这样走一遍之后是不是觉得dva的数据流向其实也并不复杂</p><script type="text/javascript" src="/js/src/bai.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;对于Dva我的理解是这样的：Dva重新组织了react项目，内置了react-router，redux，request，减少了配置这些模块的代码，将程序猿的精力都留给处理业务逻辑 &lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://www.zhangyongxuan.com/categories/React/"/>
    
    
      <category term="react" scheme="https://www.zhangyongxuan.com/tags/react/"/>
    
      <category term="前端" scheme="https://www.zhangyongxuan.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Dva" scheme="https://www.zhangyongxuan.com/tags/Dva/"/>
    
  </entry>
  
  <entry>
    <title>高阶组件入门</title>
    <link href="https://www.zhangyongxuan.com/2021/07/18/hoc/"/>
    <id>https://www.zhangyongxuan.com/2021/07/18/hoc/</id>
    <published>2021-07-18T12:41:51.000Z</published>
    <updated>2021-11-10T06:34:24.290Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><em>在React China中的一篇文章说：高阶组件本质上是一个函数，这个函数接受的参数是另一个组件，在函数内部对参数中的组件进行一系列操作之后返回出一个新的组件。以我个人理解就是个经纪公司，专门用来包装组件。</em></strong><br><a id="more"></a><br> 这是一个简单的高阶组件，它的功能是将父组件中的数据进行过滤之后传递给子组件，其中穿插了refs转发的技术点：</p><pre><code>import React from &#39;react&#39;/*这是一个高阶组件，接受两个参数，第一个参数是要包装的组件，第二个参数为string类型，表示要过滤的数据类型*/function Hoc(WrapperComponent,type){     class Hoc extends React.Component{ //首先，要包装这个组件的话需要一个组件来做容器        constructor(props){            super(props)        }        render(){            /*                在这里根据函数的第二个参数去处理Hoc组件props中接受的父组件传过来的数据            */            const {forwardRef,...others} = this.props; //（5）            /*对Hoc的props进行解构，拿到ref和其他参数，此时的ref就是在return中的forwardRef函数传递的那个ref*/            const otherProps = {...others}            let newProps = {};            for(let key in otherProps){                // console.log(typeof otherProps[key])                if(typeof otherProps[key] === type){                    newProps[key] = otherProps[key]                }            }//处理之后创建一个新的对象newProps            return (                &lt;div &gt;                    &lt;WrapperComponent {...newProps} ref = {forwardRef} /&gt;//在这里将这个newProps转给函数接受的那个组件参数，将之前解构的ref一并传给它  （6） 最终挂载到参数组件                &lt;/div&gt;            )        }    }/*在这里使用react原型上的函数forwardRef对父组件传递的ref进行转发，否则父组件传递的ref只会挂载到Hoc组件而到不了参数组件，而我们的需求是要挂载到参数组件，forwardRef函数回调中第一个参数为父组件传递的值，第二个参数为父组件传递的那个ref*/    return React.forwardRef((props,ref)=&gt;{ //（3）        return &lt;Hoc {...props} forwardRef = {ref} /&gt; // （4）    });}class Loc extends React.Component{    render(){        return (            &lt;div&gt;                Loc            &lt;/div&gt;        )    }}const HocComp = Hoc(Loc,&#39;string&#39;);class Foc extends React.Component{    constructor(props){        super(props);        this.ref = React.createRef(); //创建一个ref  （1）    }    componentDidMount(){        console.log(this.ref.current.props)        console.log(this.ref.current)    }    render(){        return (            &lt;div&gt;            //在这里将创建好的ref作为ref传递给子组件HocComp                &lt;HocComp v1 = &#39;231&#39; v2 = {123} v3 = {{a:1}} ref ={this.ref} /&gt; // （2）            &lt;/div&gt;        )    }}export default Foc</code></pre><p>以上代码中，父组件中React.createRef()方法创建的ref对象的流向用数字表示。</p><script type="text/javascript" src="/js/src/bai.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;在React China中的一篇文章说：高阶组件本质上是一个函数，这个函数接受的参数是另一个组件，在函数内部对参数中的组件进行一系列操作之后返回出一个新的组件。以我个人理解就是个经纪公司，专门用来包装组件。&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="React" scheme="https://www.zhangyongxuan.com/categories/React/"/>
    
    
      <category term="react" scheme="https://www.zhangyongxuan.com/tags/react/"/>
    
      <category term="前端" scheme="https://www.zhangyongxuan.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>react中的ref和content</title>
    <link href="https://www.zhangyongxuan.com/2021/07/17/reactref/"/>
    <id>https://www.zhangyongxuan.com/2021/07/17/reactref/</id>
    <published>2021-07-17T09:38:28.000Z</published>
    <updated>2021-11-10T06:34:24.294Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><em>一般的 react 数据流中，父级与子级是通过 props 进行 “沟通”， 如果要子级发生改变，父级可以改变传入的 props。但是有时，需要强制修改子级，这种情况下需要用到 ref</em></strong><br><a id="more"></a></p><h1 id="一般使用-ref-的场景"><a href="#一般使用-ref-的场景" class="headerlink" title="一般使用 ref 的场景:"></a>一般使用 ref 的场景:</h1><h2 id="1-处理焦点，文本选择，-媒体控制"><a href="#1-处理焦点，文本选择，-媒体控制" class="headerlink" title="1.处理焦点，文本选择， 媒体控制"></a>1.处理焦点，文本选择， 媒体控制</h2><h2 id="2-触发强制动画"><a href="#2-触发强制动画" class="headerlink" title="2.触发强制动画"></a>2.触发强制动画</h2><h2 id="3-集成第三方-dom-库"><a href="#3-集成第三方-dom-库" class="headerlink" title="3.集成第三方 dom 库"></a>3.集成第三方 dom 库</h2><pre><code>class AutoFocusTextInput extends React.Component {  componentDidMount() {    this.textInput.focusTextInput();  }  render() {    return (      &lt;CustomTextInput        ref={(input) =&gt; { this.textInput = input; }} /&gt;    );  }}</code></pre><pre><code>class CustomTextInput extends React.Component {  constructor(props) {    super(props);    this.focus = this.focus.bind(this);  }  focus() {    // 直接使用原生 API 使 text 输入框获得焦点    this.textInput.focus();  }  render() {    // 使用 `ref` 的回调将 text 输入框的 DOM 节点存储到 React    // 实例上（比如 this.textInput）    return (      &lt;div&gt;        &lt;input          type=&quot;text&quot;          ref={(input) =&gt; { this.textInput = input; }} /&gt;        &lt;input          type=&quot;button&quot;          value=&quot;Focus the text input&quot;          onClick={this.focus}        /&gt;      &lt;/div&gt;    );  }}</code></pre><h1 id="content"><a href="#content" class="headerlink" title="content"></a>content</h1><p>在 react 中，数据以自上到下的方向传递，如果一个数据在最顶层，而最底层的组件需要用到这个数据，那么数据需要传递很多层才能到达最底层。这种操作会异常麻烦。</p><p>context 可以解决这个问题</p><pre><code>//定义一个全局contextimport React from &#39;react&#39;const GlobalContext = React.createContext()export default GlobalContext//父组件中provider&lt;GlobalContext.Provider value={value}&gt;&lt;Content /&gt;&lt;/GlobalContext.Provider&gt;// 子组件&lt;GlobalContext.Consumer&gt;{value =&gt; &lt;button&gt;test-{value}&lt;/button&gt;}&lt;/GlobalContext.Consumer&gt;</code></pre><script type="text/javascript" src="/js/src/bai.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;一般的 react 数据流中，父级与子级是通过 props 进行 “沟通”， 如果要子级发生改变，父级可以改变传入的 props。但是有时，需要强制修改子级，这种情况下需要用到 ref&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="React" scheme="https://www.zhangyongxuan.com/categories/React/"/>
    
    
      <category term="react" scheme="https://www.zhangyongxuan.com/tags/react/"/>
    
      <category term="前端" scheme="https://www.zhangyongxuan.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>reactform</title>
    <link href="https://www.zhangyongxuan.com/2021/07/17/reactform/"/>
    <id>https://www.zhangyongxuan.com/2021/07/17/reactform/</id>
    <published>2021-07-17T09:30:01.000Z</published>
    <updated>2021-11-10T06:34:24.293Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><em>react表单</em></strong><br><a id="more"></a></p><h1 id="react表单中的组件根据实现方式可以分为两种："><a href="#react表单中的组件根据实现方式可以分为两种：" class="headerlink" title="react表单中的组件根据实现方式可以分为两种："></a>react表单中的组件根据实现方式可以分为两种：</h1><h2 id="1-受控组件："><a href="#1-受控组件：" class="headerlink" title="1.受控组件："></a>1.受控组件：</h2><p>相当于将表单的值与 state 状态双向绑定，实际上state 到表单 是变化重新渲染表单，表单到 state，则通过对表单元素绑定 change 方法，在其中将表单的 value 赋给state 的过程。这个过程需要自己手动去完成，而不同于react的vue则是通过一个指令进行数据的双向绑定。</p><pre><code>class NameForm extends React.Component {  constructor(props) {    super(props);    this.state = {value: &#39;&#39;};    this.handleChange = this.handleChange.bind(this);    this.handleSubmit = this.handleSubmit.bind(this);  }  handleChange(event) {    this.setState({value: event.target.value});  }  handleSubmit(event) {    alert(&#39;A name was submitted: &#39; + this.state.value);    event.preventDefault();  }  render() {    return (      &lt;form onSubmit={this.handleSubmit}&gt;        &lt;label&gt;          Name:          &lt;input type=&quot;text&quot; value={this.state.value} onChange={this.handleChange} /&gt;        &lt;/label&gt;        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;      &lt;/form&gt;    );  }}</code></pre><h2 id="2-非受控组件"><a href="#2-非受控组件" class="headerlink" title="2.非受控组件"></a>2.非受控组件</h2><p>由于受控组件每一个都要写一个对应的触发事件，如果项目中是到中后期才引入的 react，那么改动将会很大，所以可以使用非受控组件。<br>非受控组件还是和之前操作 dom 拿到表单元素的值的方式很像。</p><pre><code>class NameForm extends React.Component {  constructor(props) {    super(props);    this.handleSubmit = this.handleSubmit.bind(this);  }  handleSubmit(event) {    alert(&#39;A name was submitted: &#39; + this.input.value);    event.preventDefault();  }  render() {    return (      &lt;form onSubmit={this.handleSubmit}&gt;        &lt;label&gt;          Name:          &lt;input type=&quot;text&quot; ref={(input) =&gt; this.input = input} /&gt;        &lt;/label&gt;        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;      &lt;/form&gt;    );  }}</code></pre><script type="text/javascript" src="/js/src/bai.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;react表单&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="React" scheme="https://www.zhangyongxuan.com/categories/React/"/>
    
    
      <category term="react" scheme="https://www.zhangyongxuan.com/tags/react/"/>
    
      <category term="前端" scheme="https://www.zhangyongxuan.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>react基础</title>
    <link href="https://www.zhangyongxuan.com/2021/07/17/react01/"/>
    <id>https://www.zhangyongxuan.com/2021/07/17/react01/</id>
    <published>2021-07-17T09:27:24.000Z</published>
    <updated>2021-11-10T06:34:24.292Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><em>现在项目中使用的基本都是JSX语法，所以在这篇笔记里都用这样的写法</em></strong></p><a id="more"></a><h1 id="react"><a href="#react" class="headerlink" title="react"></a>react</h1><p>现在项目中使用的基本都是JSX语法，所以在这篇笔记里都用这样的写法</p><h2 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h2><p>Jsx 用来声明 react 中的元素</p><pre><code>const element = &lt;h1&gt;hi~ react&lt;/h1&gt;</code></pre><p>可以在jsx 当中使用 js 表达式</p><pre><code>function getDisplayName(givenName, familyName){    return givenName + familyName}const element = &lt;h1&gt;{ getDisplayName(’nena’, ’wan&#39;)}&lt;/h1&gt;</code></pre><p>可以定义以字符串为值的属性、以 js 表达式为值的属性</p><pre><code>import imageUrl from ‘../asset/image.png&#39; const element = &lt;img alt=“img” src={imageUrl} className=“imgEle&quot;/&gt; </code></pre><h2 id="react-基础语法"><a href="#react-基础语法" class="headerlink" title="react 基础语法"></a>react 基础语法</h2><pre><code>HellowWorld.jsimport React from &#39;react&#39;;class HellowWorld extends React.component{    constructor(props){        super(props);    }    render(){        return (            &lt;div&gt;HellowWorld&lt;/div&gt;        )    }}export default HellowWorld;</code></pre><p>这是一个标准的react组件，在react中约定：组件必须为大写字母开头并且使用驼峰式命名，组件名和文件名必须保持一致。</p><h2 id="react渲染"><a href="#react渲染" class="headerlink" title="react渲染"></a>react渲染</h2><p>一般渲染顶部的元素，我们使用 ReactDom.render()</p><pre><code>function tick(){   const element = (    &lt;div&gt;      &lt;h1&gt;time&lt;/h1&gt;      &lt;p&gt;{new Date().toLocaleTimeString()}&lt;/p&gt;    &lt;/div&gt;   )   ReactDom.render(   element,   document.getELementById(‘root&#39;)   ) } </code></pre><p>但是通常情况下，react 的项目，这种渲染方式只是用于最顶部的元素渲染，下面的子元素我们一般使用其他的方法，react 留给我们状态和属性变化时，相关组件即刻渲染的机制，以供我们保持数据和页面显示状态的同步。</p><h2 id="React组件-amp-props"><a href="#React组件-amp-props" class="headerlink" title="React组件&amp;props"></a>React组件&amp;props</h2><p>React 组件：相当于一个函数，可从外界获取参数，由组件中 props 接收，并最终返回一个可在页面上进行渲染的 react 元素。<br>定义组件的方法有两种：  </p><h3 id="函数式定义"><a href="#函数式定义" class="headerlink" title="函数式定义:"></a>函数式定义:</h3><pre><code>function Welcome(props){   return &lt;h1&gt;hello, { props.name }&lt;/h1&gt; } </code></pre><h3 id="Es6-类定义"><a href="#Es6-类定义" class="headerlink" title="Es6  类定义"></a>Es6  类定义</h3><pre><code>class Welcome extends React.Component {   render(){      return &lt;h1&gt;{this.props.name}&lt;/h1&gt;   } } </code></pre><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p>state为一个组件的内部状态，实际上它是一个对象，内部属性由我们决定。<br>除了调用 ReactDom.render() 方法来渲染 react 元素以外，可以更新一个组件的内部 state 值，以此来对组件进行一次重新渲染。</p><pre><code>class Add extends React.Component{   constructor(props){      super(props);      this.state = {        number: 0,      }   }    add = () =&gt; {      const currentNumber = this.state.number;      this.setState({        number: currentNumber + 1,      })   }   render() {      return(        &lt;div&gt;          &lt;h1&gt;the current number is: { this.state.number }&lt;/h1&gt;          &lt;button onClick={this.add}&gt; 加1 &lt;/button&gt;        &lt;/div&gt;      )   }}</code></pre><p>状态的合并为浅合并:</p><pre><code>   This.state = {       number: 0,       visitable: false,    }    …    this.setState({       number: 1    })    // state: { number: 1, visitable: false}</code></pre><p>react 数据流为自上而下，父级并不关心也不知道子级是否有状态，状态为什么值等。</p><p><strong><em>使用state的时候要注意的点：</em></strong><br>1.不要直接修改 state 中的值，那样不会重新进行渲染，必须要使用 setState</p><pre><code>add = () =&gt; {        const currentNumber = this.state.number;   this.state.number = currentNumber + 1;}   // 错误</code></pre><p>2.不要利用前一个 state 中变化的值马上去修改后一个 state 的值，因为 setState 是异步的，不能确定什么时候更新成功。</p><pre><code>add = () =&gt; {    this.setState(function(prev){        return {            number: prev.number + 1        }    }) } </code></pre><p>3.由于异步的关系，如果一个操作必须要在一个 setState 之后进行的话。可以使用回调函数</p><pre><code>add = () =&gt; {    this.setState(function(prev){        return {           number: prev.number + 1       }   }, function(){   // to do something...  }) } </code></pre><h2 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h2><p>组件生命周期各周期钩子继承自 React.Component</p><h3 id="当组件实例被创建及被插入dom时依次调用"><a href="#当组件实例被创建及被插入dom时依次调用" class="headerlink" title="当组件实例被创建及被插入dom时依次调用"></a>当组件实例被创建及被插入dom时依次调用</h3><pre><code>constructor() componentWillMount()render()componentDidMount()</code></pre><h3 id="当传入属性变化或者状态变化，组件要被重新渲染时依次调用"><a href="#当传入属性变化或者状态变化，组件要被重新渲染时依次调用" class="headerlink" title="当传入属性变化或者状态变化，组件要被重新渲染时依次调用"></a>当传入属性变化或者状态变化，组件要被重新渲染时依次调用</h3><pre><code>componentWillReceiveProps() shouldComponentUpdate() componentWillUpdate() render() componentDidUpdate() </code></pre><h3 id="当一个组件从-Dom-中即将被卸载时调用"><a href="#当一个组件从-Dom-中即将被卸载时调用" class="headerlink" title="当一个组件从 Dom 中即将被卸载时调用"></a>当一个组件从 Dom 中即将被卸载时调用</h3><pre><code>componentWillUnmount()</code></pre><h3 id="各周期特点及一般性使用"><a href="#各周期特点及一般性使用" class="headerlink" title="各周期特点及一般性使用:"></a>各周期特点及一般性使用:</h3><pre><code>constructor()</code></pre><p>构造函数，一般在其中 进行初始化 state，继承 props</p><pre><code>componentWillMount()</code></pre><p>在 render 之前调用，因此在这里进行 setState 操作并不会触发渲染，没有意义。<br>这个钩子在一般的前端项目中不常使用，但在服务端渲染项目中会被调用。</p><pre><code>render()</code></pre><p>根据最新的 props 和 state 进行渲染</p><pre><code>componentDidMount()</code></pre><p>在 render之后调用，可以在这里进行查询数据操作，或者对渲染好的页面进行 dom操作。</p><pre><code>componentWillReceiveProps(nextProps)</code></pre><p>在 props 即将发生变化前调用，nextProps 为新的 props, 可以通过与 this.props<br> 做比较，进而更新某些依赖 props 而发生改变的 state</p><pre><code> shouldComponentUpdate( nextProps, nextState)</code></pre><p> 当属性或者状态改变时调用，默认返回 true, 即进行渲染，如果返回 false，则不进行渲染。  后续在属性改变<br>时期触发的生命周期都不再调用。注意在初始化组件及使用forceUpdate()时不会调用。</p><pre><code>componentWillUpdate(nextProps, nextState)</code></pre><p>在上一步如果返回了 true, 则继续调用。</p><pre><code>render()</code></pre><p>进行渲染</p><pre><code>componentDidUpdate(prevProps, prevState)</code></pre><p>在这里对比之前和已经更改的 props 及 state,  进行 dom 操作或者发送请求。</p><pre><code>componentWillUnmount()</code></pre><p>在组件被销毁和卸载前调用，在此清理组件的一些定时器，网络请求等。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p> 与vue基本一样，一般形式如下</p><pre><code> handleClick(){     ..... } &lt;button onClick={(e)=&gt;{this.handleClick(e)}}&gt;add&lt;/button&gt;</code></pre><h2 id="条件渲染和列表渲染"><a href="#条件渲染和列表渲染" class="headerlink" title="条件渲染和列表渲染"></a>条件渲染和列表渲染</h2><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><pre><code> this.state = {  showNameFlag: false,  name: ’nena wan&#39;}...render() {   const showNameFlag = this.state.showNameFlag;   const name = this.state.name;   return (      &lt;div&gt;         &lt;h1&gt;Hello ~&lt;/h1&gt;         {             showNameFlag ? (&lt;p&gt;{name}&lt;/p&gt;) : null         }      &lt;/div&gt;   ) } </code></pre><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><pre><code>this.state = {    list = [        { id: 1, name: ‘apple’, meaning: ‘苹果&#39; }        { id: 2, name: ‘pear’, meaning: ‘梨&#39; },        { id: 3, name: ‘peach’, meaning: ’桃子&#39; }    ], } ...render() {  const list = this.state.list;  return (     &lt;div&gt;        &lt;h1&gt;Hello ~&lt;/h1&gt;        {            list.map(function(item, index){                Return (                  &lt;div key={item.id.toString()}&gt;                     &lt;h1&gt;{item.name} / {item.meaning}&lt;/h1&gt;                  &lt;/div&gt;                )            })        }     &lt;/div&gt;  )}</code></pre><script type="text/javascript" src="/js/src/bai.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;现在项目中使用的基本都是JSX语法，所以在这篇笔记里都用这样的写法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://www.zhangyongxuan.com/categories/React/"/>
    
    
      <category term="react" scheme="https://www.zhangyongxuan.com/tags/react/"/>
    
      <category term="前端" scheme="https://www.zhangyongxuan.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>数组常用方法</title>
    <link href="https://www.zhangyongxuan.com/2021/07/16/arrayfun/"/>
    <id>https://www.zhangyongxuan.com/2021/07/16/arrayfun/</id>
    <published>2021-07-16T08:59:43.000Z</published>
    <updated>2021-11-10T06:34:24.239Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><em>数组常用方法</em></strong><br><a id="more"></a></p><h1 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h1><h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h2><ul><li>对伪数组或可迭代对象(包括arguments Array,Map,Set,String…)转换成数组对象</li></ul><pre><code>function * fun(){    yield 1;    yield 11;    yield 111;    yield 1111;    yield 11111;}let g = fun();let arr = Array.from(g);console.log(arr); //[1, 11, 111, 1111, 11111] </code></pre><h2 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h2><ul><li>用于检测传入的参数是否为数组对象：</li></ul><pre><code>Array.isArray([]) //trueArray.isArray({}) //false</code></pre><h2 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h2><ul><li>用于生成一个由参数构成的数组</li></ul><pre><code>Array.of(7);       // [7] Array.of(1, 2, 3); // [1, 2, 3]Array(7);          // [ , , , , , , ]Array(1, 2, 3);    // [1, 2, 3]</code></pre><h2 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h2><p>用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</p><pre><code>var arr1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];    var arr2 = [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;];    var arr3 = [&#39;f&#39;];    var arr4 = arr1.concat(arr2,arr3);    // arr4 is a new array [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot; ]</code></pre><h2 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h2><ul><li>创建一个新数组, 其包含通过所提供函数实现的测试的所有元素</li></ul><pre><code>var arr= [1,10,20,30]var brr = arr.filter((item)=&gt;{    return item&gt;10;})  //[20,30]</code></pre><h2 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h2><ul><li>返回数组中满足提供的测试函数的第一个元素的值</li></ul><pre><code>function isBigEnough(element) {    return element &gt;= 15;    }    [12, 5, 8, 130, 44].find(isBigEnough); // 130</code></pre><h2 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex()"></a>findIndex()</h2><ul><li>返回数组中满足提供的测试函数的第一个元素的索引</li></ul><pre><code>function isBigEnough(element) {  return element &gt;= 15;}[12, 5, 8, 130, 44].findIndex(isBigEnough);  //&#39;3&#39;</code></pre><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h2><ul><li>方法对数组的每个元素执行一次提供的函数</li></ul><pre><code>var a = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];a.forEach(function (element, index, array) {    // element: 指向当前元素的值    // index: 指向当前索引    // array: 指向Array对象本身    console.log(element);});</code></pre><h2 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h2><ul><li>用来判断一个数组是否包含一个指定的值，如果是，酌情返回 true或 false</li></ul><pre><code>let a = [1, 2, 3];a.includes(2); // true a.includes(4); // false</code></pre><h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h2><ul><li>返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1</li></ul><pre><code>let a = [2, 9, 7, 8, 9]; a.indexOf(2); // 0 a.indexOf(6); // -1a.indexOf(7); // 2a.indexOf(8); // 3a.indexOf(9); // 1if (a.indexOf(3) === -1) {  // 数组中不包含3}</code></pre><h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><ul><li>将数组（或一个类数组对象）的所有元素连接到一个字符串中<pre><code>let a = [&#39;Wind&#39;, &#39;Rain&#39;, &#39;Fire&#39;];a.join(); // 默认为 &quot;,&quot;// &#39;Wind,Rain,Fire&#39;</code></pre><h2 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h2></li><li>创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果</li></ul><pre><code>var array1 = [1,4,9,16];const map1 = array1.map(x =&gt; x *2);console.log(map1); // Array [2,8,18,32]</code></pre><script type="text/javascript" src="/js/src/bai.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;数组常用方法&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ES6" scheme="https://www.zhangyongxuan.com/categories/ES6/"/>
    
    
      <category term="前端" scheme="https://www.zhangyongxuan.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Javascript" scheme="https://www.zhangyongxuan.com/tags/Javascript/"/>
    
      <category term="ES6" scheme="https://www.zhangyongxuan.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Generator函数和async函数</title>
    <link href="https://www.zhangyongxuan.com/2021/07/16/generatorandasync/"/>
    <id>https://www.zhangyongxuan.com/2021/07/16/generatorandasync/</id>
    <published>2021-07-16T07:18:16.000Z</published>
    <updated>2021-11-10T06:34:24.283Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><em>本文所有引用都出自—–&gt;阮一峰《ES6入门》</em></strong><br><a id="more"></a></p><h1 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h1><p>Generator函数是es6提供的一种异步编程解决方案，不同于promise的是，Generator的语法完全是以同步编程的方式来实现异步操作，而promise其实就是回调的封装，操作复杂了之后，代码看起来就是一串then函数，可读性也很低。下面是一个简单的Generator函数：</p><pre><code>function* fun(x){    let result = yield x+2; // 状态01  这里注意，yield这个关键字的作用是Generator函数向函数外部转递状态    return result; //状态02 这个Generator函数最终的状态}let g = fun(3); //首先获取Generator函数产生的遍历器对象let status1 = g.next(); //执行遍历器对象的next方法，使指针指向第一个状态 -&gt;01console.log(status1); // {value:5,done:false} value是yield后边表达式的值，done是一个布尔值，表示遍历是否结束let result = g.next(status1); //执行遍历器对象的next方法，使指针指向下一个状态-&gt;02console.log(result); // {value:5,done:false}</code></pre><blockquote><p>next方法的作用是分阶段执行Generator函数。每次调用next方法，会返回一个对象，表示当前阶段的信息（value属性和done属性）。value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。</p></blockquote><p>Generator函数有一点和普通函数一样，就是return后边的代码是不会被执行到的，当使用解构赋值查看函数执行结果的时候，它只会遍历done为false的value：</p><pre><code>function * fun(){    yield 1;    yield 2;    yield 3;    return 4;}console.log([...fun()]) //  [1, 2, 3]</code></pre><p>使用Gennerator实现异步编程的例子 ：</p><pre><code>function * fun (){    let result = yield new Promise((resolve,reject)=&gt;{        resolve({            code : 1,            msg : &#39;数据加载成功&#39;        })    }) //这里使用一个Promise对象模拟异步请求    console.log(result);}let g = fun();let status1 = g.next(); //获取状态1status1.value.then((data)=&gt;{    g.next(data);}).catch((err)=&gt;{    console.error(err);}) //{code: 1, msg: &quot;数据加载成功&quot;}</code></pre><p>首先调用第一次yield的时候执行后边那个Promise异步操作，将这个Promise对象作为遍历器对象的value属性传到函数外部，在函数外部then函数中对next方法进行第二次调用，将promise传出的data作为next函数的参数传回函数内部完成异步操作。<br><strong><em>nodejs中约定的回调函数第一个参数是error就是因为原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了。在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当作参数，传入第二段。</em></strong></p><h1 id="Thunk函数-简单了解"><a href="#Thunk函数-简单了解" class="headerlink" title="Thunk函数(简单了解)"></a>Thunk函数(简单了解)</h1><p>Thunk 函数是自动执行 Generator 函数的一种方法。</p><pre><code>// 正常版本的readFile（多参数版本）fs.readFile(fileName, callback);// Thunk版本的readFile（单参数版本）var Thunk = function (fileName) {  return function (callback) {    return fs.readFile(fileName, callback);  };};var readFileThunk = Thunk(fileName);readFileThunk(callback);</code></pre><p>上面代码中，fs模块的readFile方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做 Thunk 函数。</p><h1 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h1><p>async函数必须搭配关键字await使用，就是说只有async函数内部才可以使用await关键字。async函数其实就是Generator函数的语法糖，async函数返回的也是个promise对象。</p><pre><code>const gen = function* () {  const f1 = yield readFile(&#39;/etc/fstab&#39;);  const f2 = yield readFile(&#39;/etc/shells&#39;);  console.log(f1.toString());  console.log(f2.toString());};</code></pre><p>这是一个Generator函数读取文件的例子，改写为async/await方式就是下边这样：</p><pre><code>const asyncReadFile = async function () {  const f1 = await readFile(&#39;/etc/fstab&#39;);  const f2 = await readFile(&#39;/etc/shells&#39;);  console.log(f1.toString());  console.log(f2.toString());};</code></pre><p>我们观察后发现，从表面看来就是将*替换为async，将yield替换为await，但是它比Generator函数的有点有以下几点：</p><h3 id="1-内置执行器"><a href="#1-内置执行器" class="headerlink" title="1.内置执行器"></a>1.内置执行器</h3><p>不同于Generator函数的执行，async函数不需要去一步步调用next函数，而是只需要一行代码调用即可。</p><pre><code>async function  fun(){    let a = await new Promise((resolve,reject)=&gt;{        resolve(1111);    })    console.log(a);}fun(); //  111</code></pre><h3 id="2-更好的语义"><a href="#2-更好的语义" class="headerlink" title="2.更好的语义"></a>2.更好的语义</h3><p>相比于Generator函数的*和yield而言，async和await更加便于理解。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</p><h3 id="3-更广的适用性"><a href="#3-更广的适用性" class="headerlink" title="3.更广的适用性"></a>3.更广的适用性</h3><blockquote><p>co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</p></blockquote><h3 id="4-返回值是-Promise"><a href="#4-返回值是-Promise" class="headerlink" title="4.返回值是 Promise"></a>4.返回值是 Promise</h3><blockquote><p>async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。<br>进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</p></blockquote><h2 id="async函数执行顺序"><a href="#async函数执行顺序" class="headerlink" title="async函数执行顺序"></a>async函数执行顺序</h2><p>当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p><script type="text/javascript" src="/js/src/bai.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;本文所有引用都出自—–&amp;gt;阮一峰《ES6入门》&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ES6" scheme="https://www.zhangyongxuan.com/categories/ES6/"/>
    
    
      <category term="前端" scheme="https://www.zhangyongxuan.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Javascript" scheme="https://www.zhangyongxuan.com/tags/Javascript/"/>
    
      <category term="ES6" scheme="https://www.zhangyongxuan.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="https://www.zhangyongxuan.com/2021/07/15/promise/"/>
    <id>https://www.zhangyongxuan.com/2021/07/15/promise/</id>
    <published>2021-07-15T10:50:12.000Z</published>
    <updated>2021-11-10T06:34:24.291Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><em>就像它的含义一样，它自己的状态和外界是没有关系的</em></strong><br><a id="more"></a></p><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>在阮大佬的《ES6入门》中提到，promise就和它的意思一样，承诺了要做什么事情，那就一定会完成，pomise也是一样它有三个状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。而踏着三种状态之间的转换之和该promise对象中的操作有关，和别的因素无关，promise对象的状态变化很简单，只有两种：1、pending =&gt; rejected   2、 pending =&gt; fulfilled 这中情况的状态转换对应了promise构造函数中传进来的来个默认参数 1、resolve() 2、reject(),下边是个例子：</p><pre><code>let fun = (num) =&gt; new Promise((resolve,reject)=&gt;{    if(num%2===0){        resolve({type:&#39;偶数&#39;,value:num})    }else{        reject({type:&#39;奇数&#39;,value:num})    }})fun(2).then((data)=&gt;{console.log(data);},(data)=&gt;{console.log(data);}) //{type: &quot;偶数&quot;, value: 2} fulfilled 状态fun(3).then((data)=&gt;{console.log(data);},(data)=&gt;{console.log(data);})//{type: &quot;奇数&quot;, value: 3} rejected状态</code></pre><h1 id="异步和Promise"><a href="#异步和Promise" class="headerlink" title="异步和Promise"></a>异步和Promise</h1><p>假设有两个操作a，b  ，而b的操作需要等待a的结果，这时候这种情况就是异步，es5中通过回调来实现这样的功能，要用回调模拟ajax请求的话如下写法：</p><pre><code>function ajax(time,callback){    setTimeout(()=&gt;{        callback();        console.log(&#39;执行结束&#39;);    },time)}console.log(&#39;程序开始&#39;);ajax(2000,()=&gt;{    console.log(&#39;异步执行&#39;);})console.log(&#39;程序结束&#39;);</code></pre><p>这只是一个简单的测试demo，在真实项目当中可能操作与操作之间会一环套一环，这时候就会陷入前端程序猿们最害怕的回调地狱，当程序出现bug的时候就非常难以调试，在es中promise的出现很大程度上减轻了js异步编程的难度，同样是上边这个例子，用es6 promise写法如下：</p><pre><code>function ajax(time){return new Promise((resolve,reject)=&gt;{     setTimeout(()=&gt;{        resolve();        console.log(&#39;执行结束&#39;);        //这里只考虑成功的情况    },time)})}console.log(&#39;程序开始&#39;);ajax(2000).then(()=&gt;{    console.log(&#39;程序结束&#39;);})console.log(&#39;程序结束&#39;);</code></pre><p>这两种写法运行结果是一模一样的，但是写法却天差地别，es6 promise杜绝了es5中的那种回调嵌套回调的写法，从代码上来看，和同步编程没什么区别，所以可以理解为用同步的方式来解决异步的问题。</p><h1 id="resolve-和-reject"><a href="#resolve-和-reject" class="headerlink" title="resolve 和 reject"></a>resolve 和 reject</h1><p>pormise的resolve函数和reject函数有可能是带有参数的，在这样的情况下这个参数会传递给then 函数中对应的回调，如下代码所示：</p><pre><code>let pro = new Promise((resolve,reject)=&gt;{    setTimeout(()=&gt;{        resolve({            name : &#39;zyx&#39;,            age : 22        })    })})pro.then(data=&gt;{    console.log(data); //{name: &quot;zyx&quot;, age: 22}})</code></pre><p>有时候resolve和reject的函数可能也是个promise对象那么这两个promise对象的状态之间就会产生联系，看下面这段代码：</p><pre><code>let pro1 = new Promise((resolve,reject)=&gt;{    setTimeout(()=&gt;{        reject();    },2000)})let pro2 = new Promise((resolve,reject)=&gt;{resolve(pro1)})pro2.then(()=&gt;{    console.log(&#39;resolve&#39;)},()=&gt;{    console.log(&#39;reject&#39;)})  // reject</code></pre><p>上边这段代码中pro2的resolve函数参数是另一个promise对象pro1，这时候pro2的状态就会取决于pro1的状态，可以看到虽然pro2使用resolve函数试图将状态改变为fulfilled，但是后边还是执行了reject的回调。这种情况得注意，否则在真正的项目开发中可能会陷入逻辑上的混乱。</p><p>值得注意的是，调用resolve或者reject并不会终结promise的参数函数的执行：</p><pre><code>let pro = new Promise((resolve,reject)=&gt;{    console.log(&#39;start&#39;)    setTimeout(()=&gt;resolve(),2000)    console.log(&#39;resolve end&#39;)})pro.then(()=&gt;{    console.log(&#39;callback&#39;)})// start// resolve end// callback</code></pre><p>从这个例子的输出结果中，突然发现了一个现象，就是promise参数函数中的代码会马上执行（同步执行），而异步回调之中的代码则会等待promise对象状态发生改变之后才会执行。</p><script type="text/javascript" src="/js/src/bai.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;就像它的含义一样，它自己的状态和外界是没有关系的&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ES6" scheme="https://www.zhangyongxuan.com/categories/ES6/"/>
    
    
      <category term="前端" scheme="https://www.zhangyongxuan.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Javascript" scheme="https://www.zhangyongxuan.com/tags/Javascript/"/>
    
      <category term="ES6" scheme="https://www.zhangyongxuan.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>es6函数和类</title>
    <link href="https://www.zhangyongxuan.com/2021/07/15/funcionandclass/"/>
    <id>https://www.zhangyongxuan.com/2021/07/15/funcionandclass/</id>
    <published>2021-07-15T07:41:59.000Z</published>
    <updated>2021-11-10T06:34:24.271Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><em>从es6中做出的改变来看，JavaScript正在向一门面向对象的语言进行发展（小声bb）</em></strong><br><a id="more"></a></p><h2 id="es6函数"><a href="#es6函数" class="headerlink" title="es6函数"></a>es6函数</h2><p>箭头函数是es6中函数的一种新的写法，也是平时我们用的比较多的写法</p><h3 id="箭头函数在项目中最常用的几个点"><a href="#箭头函数在项目中最常用的几个点" class="headerlink" title="箭头函数在项目中最常用的几个点"></a>箭头函数在项目中最常用的几个点</h3><h4 id="函数配合解构赋值的用法"><a href="#函数配合解构赋值的用法" class="headerlink" title="函数配合解构赋值的用法"></a>函数配合解构赋值的用法</h4><p>其实配合解构赋值使用并不是箭头函数的专利，普通函数也可以配合解构赋值进行使用：</p><pre><code>function fun({name,age}){    return `My name is ${name},I am ${age}years old`}console.log(fun({name:&#39;zyx&#39;,age:22})) //My name is zyx,I am 22years old</code></pre><p>但是解构赋值和箭头函数都是es6新增特性，所以要用新的就都用新的啊，不然多low：</p><pre><code>let fun = ({name,age})=&gt; `My name is ${name},I am ${age}years old`;console.log(fun({name:&#39;zyx&#39;,age:22})) //My name is zyx,I am 22years old</code></pre><p>这两段代码对比之下，箭头函数显得更加简洁明了</p><h4 id="配合扩展运算符的用法"><a href="#配合扩展运算符的用法" class="headerlink" title="配合扩展运算符的用法"></a>配合扩展运算符的用法</h4><p>个人觉得这个功能就是阮大佬在<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">《es6入门》</a>一书函数的扩展一章中提到的rest参数：</p><pre><code>let fun = (a,...prams)=&gt;{    console.log(prams)}fun(1,2,3,4) // [2,3,4]</code></pre><p>我自己说实话还没发现两者有什么不同</p><h4 id="函数的默认参数设置"><a href="#函数的默认参数设置" class="headerlink" title="函数的默认参数设置"></a>函数的默认参数设置</h4><p>这也不是箭头函数的专利，es6对函数的这一扩展在真实的项目中比较实用，在我们真实的项目中存在着各种各样的情况，所以这时候默认值的作用就举足轻重了，它可以避免很多莫名其妙的可能会让你始料不及的错误,在es5中我们是这样解决默认值问题的：</p><pre><code>function fun (x,y){    var y = y ? y : 1;    return x + y;}console.log(fun(2)) // 输出3</code></pre><p>而上边这段代码经过es6改写之后变成了：</p><pre><code>let fun = (x,y=1)=&gt;x+y;console.log(fun(2)) // 输出3</code></pre><p>箭头函数加默认值设置将代码缩减为2行，这就是es6的魅力</p><h4 id="多重调用"><a href="#多重调用" class="headerlink" title="多重调用"></a>多重调用</h4><pre><code>    let sums = n =&gt; m =&gt; m+n;    console.log(sums(1)(2)); // 3    console.log(sums(1)); // m =&gt; m+n</code></pre><p>分析上边这段代码，sums函数接收一个参数之后返回了一个接受一个参数的函数，这个函数返回了两个参数的和，说起来可能有点绕口，那么将代码还原为es5是什么样的呢，如下：</p><pre><code>function sums(n){    return function(m){        return m+n;    }}console.log(sums(1)(2)); // 3console.log(sums(1)); // ƒ (m){return m+n;}</code></pre><p>在我看来这个写法有点像闭包（虽然我也不太理解闭包），在我的理解当中一个函数的返回值是另外一个函数的时候就产生了闭包。</p><p>话说在这种对比之下箭头函数和传统函数高下立见！</p><h2 id="es6-class"><a href="#es6-class" class="headerlink" title="es6 class"></a>es6 class</h2><h3 id="以下内容纯属个人理解，大佬们请轻点pen"><a href="#以下内容纯属个人理解，大佬们请轻点pen" class="headerlink" title="以下内容纯属个人理解，大佬们请轻点pen"></a><center><strong><em>以下内容纯属个人理解，大佬们请轻点pen</em></strong></center></h3><p>class关键字是用来定义一个类，在es6之前js被定义为一门基于对象的弱类型脚本语言，之所以说它是基于对象而不是面向对象，就是因为在es6之前js根本没有类的概念，但很奇怪的是它有对象的概念，所以就被定义为基于对象的语言，更加奇怪的是它没有类的概念竟然也可以进行面向对象的编程：</p><pre><code>function People(name,age){    this.name = name;    this.age = age;} //不管装的多像是构造方法，那也不是真正的构造方法People.prototype.say = function(){    console.log(&#39;My name is &#39;+this.name+&#39; ,I am &#39;+this.age+&#39; years old&#39;)}var zyx = new People(&#39;zyx&#39;,22); //假装是new一个对象zyx.say(); //My name is zyx ,I am 22 years old</code></pre><p>这样的写法和那些面向对象的语言比如java中面向对象编程的写法大相径庭，本来基于对象就已经很奇怪了，现在这样一门基于对象的语言竟然还有这样奇怪的面向对象编程方式，那岂不是让不了解的人更加觉得js是一门“不正经”的语言，所以es引入了class关键字，引入了类的概念，但这并不代表js就已经蜕变为像java那样的面向对象的语言了，js蜕变之路从es6才刚刚开始，据我所知class关键字只是一个语法糖，它的内部原理其实和上边这种写法一样，方法全在该对象的prototype属性上，但是起码写法上比较符合那些面向对象的语言中的面向对象的编程：</p><pre><code>class People{    constructor(name,age){        this.name = name;        this.age = age;    }    say(){        console.log(`My name is ${this.name}, I am ${this.age} years old`)    }}let zyx = new People(&#39;zyx&#39;,23); //注意这里，class定义的类只能通过new关键字来创建实例zyx.say();//My name is zyx ,I am 23 years old</code></pre><p><strong><em>为了更加趋向于面向对象，es6限制了class定义的类只能用new关键字去创建实例</em></strong></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><pre><code>export default calss XXX extends Component{}</code></pre><p>据说react.js中到处是这样的写法，但是我本人目前还没有系统的学习过react，所以za也不知道，za也不敢说，za也不敢问啊。</p><p><strong><em>既然有类的概念了，那么继承肯定是必不可少的，用我们公司大佬的话来说继承就是（咳咳，该拿出笔记本记笔记了）：将一些可以重复使用的代码抽象，放到顶层已供更多组件去使用，从而减少重复代码，提高代码质量的一种方法</em></strong></p><p>那么es6中既然有class，那必然会有extends了，下边简单的以上边那个people类为父类举个栗子（个人比较喜欢吃这家的栗子）：</p><pre><code>class ShangHaiPeople extends People {    constructor(name,age,money){        super(name,age);        this.money = money;    }    say(){        console.log(`My name is ${this.name}, I am ${this.age} years old，I am a ShangHaiPeople,I have ￥ ${this.money}`)    }}let zyx = new ShangHaiPeople(&#39;zyx&#39;,22,100000000)zyx.say();//My name is zyx, I am 22 years old，I am a ShangHaiPeople,I have ￥ 100000000</code></pre><script type="text/javascript" src="/js/src/bai.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;从es6中做出的改变来看，JavaScript正在向一门面向对象的语言进行发展（小声bb）&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ES6" scheme="https://www.zhangyongxuan.com/categories/ES6/"/>
    
    
      <category term="前端" scheme="https://www.zhangyongxuan.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面向对象" scheme="https://www.zhangyongxuan.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="Javascript" scheme="https://www.zhangyongxuan.com/tags/Javascript/"/>
    
      <category term="ES6" scheme="https://www.zhangyongxuan.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6新特性</title>
    <link href="https://www.zhangyongxuan.com/2021/07/12/es6day1/"/>
    <id>https://www.zhangyongxuan.com/2021/07/12/es6day1/</id>
    <published>2021-07-12T08:01:04.000Z</published>
    <updated>2021-11-10T06:34:24.259Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><em>ES6是EMCAScript标准的第6次重大改版</em></strong><br><a id="more"></a></p><h1 id="es6变量相较于es5的主要区别"><a href="#es6变量相较于es5的主要区别" class="headerlink" title="es6变量相较于es5的主要区别"></a>es6变量相较于es5的主要区别</h1><h2 id="1、不存在变量提升"><a href="#1、不存在变量提升" class="headerlink" title="1、不存在变量提升"></a>1、不存在变量提升</h2><pre><code>    console.log(a); //输出undefined    var a = 0;    console.log(b); //报错 变量b未定义    let b = 2;</code></pre><p>使用var定义的变量存在变量提升的现象，就是在变量被定义之前可以引用，值为undefined，而使用let定义的变量不存在变量提升的现象，所以在定义之前引用会报错</p><h2 id="2、会产生暂时性死区（temporal-dead-zone，简称-TDZ）"><a href="#2、会产生暂时性死区（temporal-dead-zone，简称-TDZ）" class="headerlink" title="2、会产生暂时性死区（temporal dead zone，简称 TDZ）"></a>2、会产生暂时性死区（temporal dead zone，简称 TDZ）</h2><p>什么是TDZ呢？</p><p>我个人的理解是：从块级作用域的开始起，直到let关键字声明一个变量结束的这段区域就是该变量的TDZ，下边举例说明：</p><pre><code>var a = 1;{//TDZ开始    console.log(a); //报错  Uncaught ReferenceError    let a = 2; //TDZ结束    console.log(a);//2}</code></pre><p>在全局有一个a变量，在代码块里又用了let关键字声明了一个a变量，这时候a变量就绑定了该块级作用域，在这个块级作用域中let声明a之前都属于a变量的TDZ，在一个变量的TDZ中引用它都会报Uncaught ReferenceError错误，这就导致了typeof操作并不能保证100%安全，如下代码：</p><pre><code>typeof a // undefinedvar a = 1;typeof b //Uncaught ReferenceErrorlet b =1;typeof c //undefined 变量未声明的话反而是安全的</code></pre><h2 id="3、变量不可重复声明"><a href="#3、变量不可重复声明" class="headerlink" title="3、变量不可重复声明"></a>3、变量不可重复声明</h2><p>es5中存在变量覆盖的现象，也就是说var声明的变量可以重名，而es6中的let和const变量不允许在同一作用域出现同名变量，只要在一个块级作用域有let或者const变量，那么这个变量就不可以重名，跟上边说的变量绑定一样：</p><pre><code>{    let a = 1;    var a = 1;//报错    let b = 1;    let b = 2;//报错    var c = 3;    let c = 5;//报错}</code></pre><p><strong><em>特别要注意的是，ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</em></strong></p><h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p>阮一峰大佬的《ECMAScript 6 入门》一书中对于结构复制的解释相当简单明了，他是这样说的：ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p><p>什么是模式匹配呢？个人理解就是“=”左右两边的数据的“结构”是一样就可以，最简单的例子：</p><pre><code>let [a, b, c] = [1, 2, 3];//a=1 b=2 c=3</code></pre><p>没错就是这么简单</p><p>那么什么样的数据类型可以被解构呢？大佬说：“可遍历的结构就可以被解构”，我们暂时可以理解为具有length属性的数据类型都可以被解构，比如数组、字符串、对象，如下：</p><pre><code>let [a,b,c] = &#39;qwe&#39;; // a = &#39;q&#39; b = &#39;w&#39; c = &#39;e&#39;let {name,age}  = {    name : &#39;qqq&#39;,    age : 2} // name = &#39;qqq&#39;  age = 2//支持复杂数据类型的解构let {code,json:{data}} = {    code : 2,    json : {        data : [1,2,3]    }}// code = 2 data = 123</code></pre><p>解构赋值允许不完全解构</p><hr><p>解构赋值允许设置默认值,当变量对应的被结构的数据中的undefined的时候，默认值才会生效，而且要是默认值为待计算的值（函数或者表达式）的时候，只有默认值生效的时候才会去计算它的值，这叫惰性求值，上代码：</p><pre><code>let [,b=1] = [1,4]; //b = 4 因为被解构的数据中存在b对应的值，所以默认值不生效let [,b=2] = [1]; //b = 2 //惰性求值let a = funtion () {    console.log(&#39;求值&#39;)    return 4;}let [,b = a()] = [1,2]// b  = 2 控制台不打印&#39;求值&#39;let [,b = a()] = [2]// b  = 4 控制台打印&#39;求值&#39;</code></pre><h2 id="有一点要特别注意：在解构赋值之中能不用圆括号就不要用圆括号"><a href="#有一点要特别注意：在解构赋值之中能不用圆括号就不要用圆括号" class="headerlink" title="有一点要特别注意：在解构赋值之中能不用圆括号就不要用圆括号"></a>有一点要特别注意：在解构赋值之中能不用圆括号就不要用圆括号</h2><h1 id="es6函数的扩展常用点"><a href="#es6函数的扩展常用点" class="headerlink" title="es6函数的扩展常用点"></a>es6函数的扩展常用点</h1><h2 id="1、函数参数可以使用默认值"><a href="#1、函数参数可以使用默认值" class="headerlink" title="1、函数参数可以使用默认值"></a>1、函数参数可以使用默认值</h2><p>话不多说，直接上代码：</p><pre><code>function fun (a , b = 8) {    return [a,b];}fun(1,2); //[1,2]fun(1); //[1,8]</code></pre><h2 id="需要注意的是："><a href="#需要注意的是：" class="headerlink" title="需要注意的是："></a>需要注意的是：</h2><p><strong><em>1、函数的参数是默认声明的，所以不能在函数内部使用let或者const关键字再次声明，如下错误操作</em></strong></p><pre><code>function fun (x = 6) {    let x = 5;    const x = 3;}</code></pre><p><strong><em>2、当使用函数默认参数时函数的形参也不允许有同名：</em></strong></p><pre><code>// 不报错function fun(x, x, y) {  // ...}// 报错function fun(x, x, y = 1) {  // ...}// SyntaxError: Duplicate parameter name not allowed in this context</code></pre><h2 id="2、rest参数"><a href="#2、rest参数" class="headerlink" title="2、rest参数"></a>2、rest参数</h2><p>在es6以前函数内部有一个叫arguments的类数组对象保存着函数的参数，在es6中引进了一种新的参数，叫rest参数，该参数表示形式为（…参数名）来代替arguments对象来表示函数多余的参数,这是一个数组，下边是使用rest参数完成求和功能的一个函数：</p><pre><code>function add (...nums){    let sum = 0;    for(let v of nums){        sum+=v    }    return sum;}console.log(add(1,2,3)) // 6</code></pre><h3 id="需要特别注意的有两点："><a href="#需要特别注意的有两点：" class="headerlink" title="需要特别注意的有两点："></a>需要特别注意的有两点：</h3><p><strong><em>1、rest参数之后不能有其他参数</em></strong></p><pre><code>function fun (x , ...values , y){}//Uncaught SyntaxError: Rest parameter must be last formal parameter</code></pre><p><strong><em>2、函数的length属性不计算rest参数</em></strong></p><pre><code>function fun (x,y,...values){}console.log(fun.length) // 2</code></pre><h2 id="3、箭头函数"><a href="#3、箭头函数" class="headerlink" title="3、箭头函数"></a>3、箭头函数</h2><p>箭头函数是es6中加入标准的一种类似于Lambda拉姆达表达式的语法糖吧，纯属个人理解，话不多说直接上代码：</p><pre><code>var f = v =&gt; v;// 等同于var f = function (v) {  return v;};var f = () =&gt; 5;// 等同于var f = function () { return 5 };var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) {  return num1 + num2;};</code></pre><p>用起来是相当方便啊，不过在使用的时候要注意以下几点：</p><p><strong><em>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。也就是说this对象的指向是可变的，但在箭头函数中this对象的指向是固定的。</em></strong></p><pre><code>function foo() {  setTimeout(() =&gt; {    console.log(&#39;id:&#39;, this.id);  }, 100);}var id = 21;foo.call({ id: 42 });</code></pre><p>上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。</p><p><strong><em>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</em></strong></p><p><strong><em>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</em></strong></p><p><strong><em>（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</em></strong></p><h3 id="有两种场合不适合使用箭头函数"><a href="#有两种场合不适合使用箭头函数" class="headerlink" title="有两种场合不适合使用箭头函数"></a>有两种场合不适合使用箭头函数</h3><h4 id="1、定义对象的方法，且该方法内部包括this。"><a href="#1、定义对象的方法，且该方法内部包括this。" class="headerlink" title="1、定义对象的方法，且该方法内部包括this。"></a>1、定义对象的方法，且该方法内部包括this。</h4><pre><code>const cat = {  lives: 9,  jumps: () =&gt; {    this.lives--;  }}</code></pre><p>上面代码中，cat.jumps()方法是一个箭头函数，这是错误的。调用cat.jumps()时，如果是普通函数，该方法内部的this指向cat；如果写成上面那样的箭头函数，使得this指向全局对象，因此不会得到预期结果。这是因为对象不构成单独的作用域，导致jumps箭头函数定义时的作用域就是全局作用域。</p><h4 id="2、需要动态this的时候，也不应使用箭头函数。"><a href="#2、需要动态this的时候，也不应使用箭头函数。" class="headerlink" title="2、需要动态this的时候，也不应使用箭头函数。"></a>2、需要动态this的时候，也不应使用箭头函数。</h4><pre><code>var button = document.getElementById(&#39;press&#39;);button.addEventListener(&#39;click&#39;, () =&gt; {  this.classList.toggle(&#39;on&#39;);});</code></pre><p>上面代码运行时，点击按钮会报错，因为button的监听函数是一个箭头函数，导致里面的this就是全局对象。如果改成普通函数，this就会动态指向被点击的按钮对象。</p><p>另外，如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。</p><h1 id="数组扩展常用点"><a href="#数组扩展常用点" class="headerlink" title="数组扩展常用点"></a>数组扩展常用点</h1><h2 id="1、扩展运算符"><a href="#1、扩展运算符" class="headerlink" title="1、扩展运算符"></a>1、扩展运算符</h2><p>数组的扩展运算符表示形式类似于函数的rest参数也是（…），但是它作用正好是rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p><pre><code>console.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5[...document.querySelectorAll(&#39;div&#39;)]</code></pre><h3 id="扩展运算符的常见应用"><a href="#扩展运算符的常见应用" class="headerlink" title="扩展运算符的常见应用"></a>扩展运算符的常见应用</h3><p><strong><em>1、复制数组</em></strong><br>看下边这段代码</p><pre><code>var arr1 = [1,2];var arr2 = arr1;arr2[0] = 2;console.log(arr1) // [2,2]</code></pre><p>我们都知道数组是一种引用类型，采用赋值的方式复制数组是不可取的，因为arr1和arr2都指向同一个对象，所以修改arr2会改变arr1的值，在es5中要复制数组只能通过下边的方式：</p><pre><code>var a1 = [1, 2];var a2 = a1.concat();a2[0] = 2;a1 // [1, 2]</code></pre><p>在es6中可以通过数组的扩展运算符来对数组进行复制，而不改变原来的数组：</p><pre><code>const a1 = [1, 2];// 写法一const a2 = [...a1];// 写法二const [...a2] = a1;</code></pre><p><strong><em>2、合并数组</em></strong></p><pre><code>const arr1 = [&#39;a&#39;, &#39;b&#39;];const arr2 = [&#39;c&#39;];const arr3 = [&#39;d&#39;, &#39;e&#39;];// ES5 的合并数组arr1.concat(arr2, arr3);// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]// ES6 的合并数组[...arr1, ...arr2, ...arr3]</code></pre><p>这是es5和es6合并数组写法上的区别</p><pre><code>const a1 = [{ foo: 1 }];const a2 = [{ bar: 2 }];const a3 = a1.concat(a2);const a4 = [...a1, ...a2];a3[0] === a1[0] // truea4[0] === a1[0] // true</code></pre><p>上面代码中，a3和a4是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了原数组的成员，会同步反映到新数组。</p><p><strong><em>3、与解构赋值结合</em></strong></p><pre><code>const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest  // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest  // []const [first, ...rest] = [&quot;foo&quot;];first  // &quot;foo&quot;rest   // []</code></pre><p>要注意的一点是：如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p><pre><code>const [...butLast, last] = [1, 2, 3, 4, 5];// 报错const [first, ...middle, last] = [1, 2, 3, 4, 5];// 报错</code></pre><p><strong><em>4、将可遍历对象转换为数组</em></strong></p><pre><code>let nodeList = document.querySelectorAll(&#39;div&#39;);let array = [...nodeList];[...&#39;hello&#39;] // [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</code></pre><p>所谓可遍历对象在es6中的就是实现了Iterator 接口的对象，所以Map 和 Set 结构，Generator 函数返回的Generator的</p><pre><code>let map = new Map([  [1, &#39;one&#39;],  [2, &#39;two&#39;],  [3, &#39;three&#39;],]);let arr = [...map.keys()]; // [1, 2, 3]const go = function*(){  yield 1;  yield 2;  yield 3;};[...go()] // [1, 2, 3]</code></pre><p>要注意如果对没有实现Iterator接口的对象也就是不可遍历的对象使用扩展运算符的话会报错</p><pre><code>let a = 1;[...a] //Uncaught TypeError: number 1 is not iterable (cannot read property Symbol(Symbol.iterator))</code></pre><script type="text/javascript" src="/js/src/bai.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;ES6是EMCAScript标准的第6次重大改版&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ES6" scheme="https://www.zhangyongxuan.com/categories/ES6/"/>
    
    
      <category term="前端" scheme="https://www.zhangyongxuan.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Javascript" scheme="https://www.zhangyongxuan.com/tags/Javascript/"/>
    
      <category term="ES6" scheme="https://www.zhangyongxuan.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>git入门</title>
    <link href="https://www.zhangyongxuan.com/2021/07/11/git/"/>
    <id>https://www.zhangyongxuan.com/2021/07/11/git/</id>
    <published>2021-07-11T14:16:57.000Z</published>
    <updated>2021-11-10T06:34:24.290Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><em>上班第一天，终于强迫自己学会了git的基本应用</em></strong><br><a id="more"></a></p><h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><p>什么是git？</p><p>git就是全球最好用的一个版本控制工具，一种分布式的版本控制工具。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><code>git clone [url]</code> //克隆远程仓库代码</p><p> <code>git add</code> //将想要快照的内容写入缓存区</p><p> <code>git status</code> //绿色文件表示添加到缓存区的文件有改动；红色表示添加到缓存区的文件没有改动</p><p> <code>git commit -m</code> //‘第一次版本提交’ -m选项添加备注信息</p><p> <code>git clone url</code> //使用 git clone 拷贝一个 Git 仓库到本地</p><p><code>git diff</code>  //尚未缓存的改动</p><p><code>git diff --cached</code>　//查看已缓存的改动</p><p><code>git diff HEAD</code>  //查看已缓存的与未缓存的所有改动</p><p> <code>diff git diff --stat</code>　　//显示摘要而非整个</p><p><code>git commit -a</code>  //跳过git add 提交缓存的流程 </p><p><code>git reset HEAD</code>  //用于取消已缓存的内容</p><p><code>git rm file</code><br>　　//git rm 会将条目从缓存区中移除。这与 git reset HEAD 将条目取消缓存是有区别的。<br>　　“取消缓存”的意思就是将缓存区恢复为我们做出修改之前的样子。<br>　　默认情况下，git rm file 会将文件从缓存区和你的硬盘中（工作目录）删除。</p><p><code>git mv</code>   //重命名磁盘上的文件 如 git mv README README.md</p><p><code>git push -u origin master</code> //提交代码</p><h2 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h2><p>git-flow主要有5中分支：master、hotfix、release、develop、feature<br><img src="https://upload-images.jianshu.io/upload_images/1416338-2b5d1a64e15419d7.png" alt="git-flow分支图" title="git-flow分支图"></p><p>feature分支开始于develop分支，完成以后合并到develop分支。<br>当完成一定数量feature分支以后，从develop再开一个release分支出来，这些特性将被更行到下一个发布的版本中，之后的feature将不会被合并到release中。<br>之后在release分支中，只修改bug，然后完成release分支。完成release分支会完成以下三个操作：1、合并release分支到master；2、给master打上版本的标签；3、release回归到develop分支。<br>当发现master上有bug时，开一个hotfix，完成后合并到master分支。<br><a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow" target="_blank" rel="noopener">Gitflow Workflow文档</a></p><h3 id="分支常用命令"><a href="#分支常用命令" class="headerlink" title="分支常用命令"></a>分支常用命令</h3><p> <code>git checkout [分支名]</code>//切换到指定分支</p><p> <code>git branch [分支名]</code> //创建分支命令</p><p> <code>git branch [分支名]</code> //列出分支</p><p> <code>git checkout [分支名]</code> //切换分支命令</p><p> <code>git merge [分支名]</code> //合并分支</p><p> <code>git checkout -b [分支名]</code> //创建新分支并立即切换到该分支下</p><p> <code>git branch -d [分支名]</code> //删除分支命令 </p><p><strong><em>ps:状态 uu 表示冲突未解决 可以用 git add 要告诉 Git 文件冲突已经解决</em></strong></p><h2 id="查看提交日志"><a href="#查看提交日志" class="headerlink" title="查看提交日志"></a>查看提交日志</h2><p><code>git log</code> //命令列出历史提交记录</p><p><code>git log -n</code> //命令列出历史提交记录前三条</p><p><code>git log --oneline</code> //查看历史记录的简洁的版本</p><p><code>git log --oneline --graph</code> //查看历史中什么时候出现了分支、合并</p><h2 id="提交本地修改"><a href="#提交本地修改" class="headerlink" title="提交本地修改"></a>提交本地修改</h2><p> <code>git commit -m [修改信息]</code></p><h2 id="拉取远程仓库代码"><a href="#拉取远程仓库代码" class="headerlink" title="拉取远程仓库代码"></a>拉取远程仓库代码</h2><p> <code>git pull</code> //从远端仓库提取数据并尝试合并到当前分支</p><p> <code>git fetch</code> //从远程仓库下载新分支与数据</p><h2 id="版本回滚"><a href="#版本回滚" class="headerlink" title="版本回滚"></a>版本回滚</h2><p> <code>git log -n</code>  //查看最近n条提交日志</p><p> <code>git reset -hard [版本标识]</code> //回滚到指定版本</p><p> <code>git push -f origin matser</code>  //强制提交</p><h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><ul><li>.gitignore 文件是git的一套忽略规则，对该文件所在目录以及所在目录子目录都有效，该文件一般格式为：<pre><code># 以&#39;#&#39;开始的行，被视为注释.                            # 忽略掉所有文件名是 foo.txt的文件.foo.txt# 忽略所有生成的 html文件,*.html# foo.html是手工维护的，所以例外.!foo.html# 忽略所有.o和 .a文件.*.[oa]配置语法：# 以斜杠“/”开头表示目录；# 以星号“*”通配多个字符；# 以问号“?”通配单个字符以方括号“[]”包含单个字符的匹配列表；以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；</code></pre></li></ul><p>这里需要注意的是，该文件必须在第一次推代码的时候就创建，如果你不慎在创建.gitignore文件之前就push了项目，那么即使你在.gitignore文件中写入新的过滤规则，这些规则也不会起作用，Git仍然会对所有文件进行版本管理。<br>简单来说，出现这种问题的原因就是Git已经开始管理这些文件了，所以你无法再通过过滤规则过滤它们。因此一定要养成在项目开始就创建.gitignore文件的习惯，否则一旦push，处理起来会非常麻烦。<br>那么，如果在.gitignore文件创建之后需要忽略某个文件该怎么办？这里还有一种命令忽略的方式。  </p><ul><li><p>.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。正确的做法是在每个clone下来的仓库中手动设置不要检查特定文件的更改情况。命令为：</p><pre><code>git update-index --assume-unchanged &lt;filename&gt; </code></pre><p>如果要还原的话，使用命令：</p><pre><code>git update-index --no-assume-unchanged &lt;filename&gt;</code></pre></li><li><p>使用.git/info/exclude<br>git 还提供了另一种 exclude 的方式来做同样的事情，不同的是 .gitignore 这个文件本身会提交到版本库中去。用来保存的是公共的需要排除的文件。而 .git/info/exclude 这里设置的则是你自己本地需要排除的文件。 他不会影响到其他人。也不会提交到版本库中去。<br>举例：</p><pre><code># git ls-files --others --exclude-from=.git/info/exclude# Lines that start with &#39;#&#39; are comments.# For a project mostly in C, the following would be a good set of# exclude patterns (uncomment them if you want to use them):# *.[oa]# *~.gradle/.idea/.settings/appcompat_v7/bin/build/gen/gradle/out/proguard/ship/target/.classpath.gitignore.idea.project.readme.update-config*.imllocal.properties</code></pre><p>.gitignore 还有个有意思的小功能， 一个空的 .gitignore 文件 可以当作是一个 placeholder 。当你需要为项目创建一个空的 log 目录时， 这就变的很有用。 你可以创建一个 log 目录 在里面放置一个空的 .gitignore 文件。这样当你 clone 这个 repo 的时候 git 会自动的创建好一个空的 log 目录了。</p></li></ul><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>为软件发布创建标签是推荐的。这个概念早已存在，在 SVN 中也有。你可以执行如下命令创建一个叫做 1.0.0 的标签：<br><code>git tag 1.0.0 1b2e1d63ff</code><br>1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。可以使用下列命令获取提交 ID：<br>git log<br>你也可以使用少一点的提交 ID 前几位，只要它的指向具有唯一性</p><script type="text/javascript" src="/js/src/bai.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;上班第一天，终于强迫自己学会了git的基本应用&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="git" scheme="https://www.zhangyongxuan.com/categories/git/"/>
    
    
      <category term="git" scheme="https://www.zhangyongxuan.com/tags/git/"/>
    
      <category term="版本控制" scheme="https://www.zhangyongxuan.com/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>常用API地址</title>
    <link href="https://www.zhangyongxuan.com/2021/07/11/api/"/>
    <id>https://www.zhangyongxuan.com/2021/07/11/api/</id>
    <published>2021-07-11T14:11:55.000Z</published>
    <updated>2021-11-10T06:34:24.227Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><em>一些常用技术栈的API链接</em></strong></p><a id="more"></a><p><a href="https://yarn.bootcss.com/docs/usage/" target="_blank" rel="noopener">yarn</a></p><p><a href="https://git-scm.com/" target="_blank" rel="noopener">git</a></p><p><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">ES6 文档 </a></p><p><a href="http://lesscss.cn/" target="_blank" rel="noopener">less 文档</a></p><p><a href="https://react.docschina.org/" target="_blank" rel="noopener">react官方文档</a></p><p><a href="https://dvajs.com/" target="_blank" rel="noopener">dva 文档</a></p><p><a href="https://cn.redux.js.org/" target="_blank" rel="noopener">redux文档</a></p><p><a href="https://www.webpackjs.com/" target="_blank" rel="noopener">webpack文档</a></p><p><a href="https://redux-saga-in-chinese.js.org/" target="_blank" rel="noopener">redux-saga文档</a></p><p><a href="https://reacttraining.com/react-router/web/example/basic" target="_blank" rel="noopener">react-router文档</a></p><script type="text/javascript" src="/js/src/bai.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;一些常用技术栈的API链接&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="api" scheme="https://www.zhangyongxuan.com/tags/api/"/>
    
  </entry>
  
  <entry>
    <title>React版HellowWorld</title>
    <link href="https://www.zhangyongxuan.com/2021/06/15/startreact/"/>
    <id>https://www.zhangyongxuan.com/2021/06/15/startreact/</id>
    <published>2021-06-15T01:49:57.000Z</published>
    <updated>2021-11-10T06:34:24.227Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><em>紧张刺激的毕业设计悄然进入尾声，我终于迫于生计放弃了刚刚学了点皮毛的Vue，拿起了《React引领未来的用户界面开发框架》，都是心酸啊，但是还是要在前端的路上继续摸索呀</em></strong><br><a id="more"></a></p><h3 id="React-是什么"><a href="#React-是什么" class="headerlink" title="React 是什么"></a>React 是什么</h3><p>React 是一个用于构建用户界面的 JAVASCRIPT 库。</p><p>React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。</p><p>React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。</p><p>React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。</p><p>嗯。。。这就是作为一个菜鸟，队react的初步认识。</p><h3 id="React版HellowWorld教程"><a href="#React版HellowWorld教程" class="headerlink" title="React版HellowWorld教程"></a>React版HellowWorld教程</h3><p>HellowWorld是我们程序猿入门一门编程语言的时候的第一个“项目”<br>现在无论是前端开发还是后端开发，都趋于工程化模块化的开发模式了，所以在这里本菜鸟就只记录最方便实用的脚手架使用方法。</p><h4 id="1-安装环境"><a href="#1-安装环境" class="headerlink" title="1.安装环境"></a>1.安装环境</h4><p>首先肯定是需要node环境的，作为一个21世纪的前端程序猿，如果你没了解过node的话，那么恭喜你，你已经OUT了，不开玩笑地说，前端程序员一定要去了解node的<br>至于node环境的安装，那简直是简单的不能再简单了，windows系统下的node环境搭建就像安装一个游戏一样简单，linux环境有点小复杂，但不是问题，谢谢伟大的菜鸟教程给予本菜鸟的大力支持，谢谢！谢谢！<br><a href="https://www.runoob.com/nodejs/nodejs-tutorial.html" target="_blank" rel="noopener">全套教程点击这里👈</a></p><h4 id="2-安装并使用react脚手架创建项目"><a href="#2-安装并使用react脚手架创建项目" class="headerlink" title="2.安装并使用react脚手架创建项目"></a>2.安装并使用react脚手架创建项目</h4><p>在这里我是使用node的包管理器npm来安装react脚手架<br>全局安装react脚手架</p><pre><code>$ cnpm install -g create-react-app</code></pre><p>在某盘某文件夹下打开cmd，运行下边命令创建项目</p><pre><code>$ create-react-app reacttest</code></pre><p>这时候，项目已经搭建好了,项目目录如下：</p><pre><code>reacttest/  README.md  node_modules/  package.json  .gitignore  public/    favicon.ico    index.html    manifest.json  src/    App.css    App.js    App.test.js    index.css    index.js    logo.svg</code></pre><p>运行项目</p><pre><code>$ cd reacttest/$ npm start</code></pre><p>这时候静静等待启动完成，它会自动打开一个react官方示例页面，到这里React版的HellowWorld就完成了</p><script type="text/javascript" src="/js/src/bai.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;紧张刺激的毕业设计悄然进入尾声，我终于迫于生计放弃了刚刚学了点皮毛的Vue，拿起了《React引领未来的用户界面开发框架》，都是心酸啊，但是还是要在前端的路上继续摸索呀&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="React" scheme="https://www.zhangyongxuan.com/categories/React/"/>
    
    
      <category term="react" scheme="https://www.zhangyongxuan.com/tags/react/"/>
    
      <category term="前端" scheme="https://www.zhangyongxuan.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
